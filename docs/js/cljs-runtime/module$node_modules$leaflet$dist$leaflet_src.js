shadow$provide.module$node_modules$leaflet$dist$leaflet_src = function(require, module, exports) {
  (function(global, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.leaflet = {}));
  })(this, function(exports) {
    function extend(dest) {
      var i, len;
      var j = 1;
      for (len = arguments.length; j < len; j++) {
        var src = arguments[j];
        for (i in src) {
          dest[i] = src[i];
        }
      }
      return dest;
    }
    function bind(fn, obj) {
      var slice = Array.prototype.slice;
      if (fn.bind) {
        return fn.bind.apply(fn, slice.call(arguments, 1));
      }
      var args = slice.call(arguments, 2);
      return function() {
        return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
      };
    }
    function stamp(obj) {
      "_leaflet_id" in obj || (obj._leaflet_id = ++lastId);
      return obj._leaflet_id;
    }
    function throttle(fn, time, context) {
      var lock, args, wrapperFn;
      var later = function() {
        lock = !1;
        args && (wrapperFn.apply(context, args), args = !1);
      };
      return wrapperFn = function() {
        lock ? args = arguments : (fn.apply(context, arguments), setTimeout(later, time), lock = !0);
      };
    }
    function wrapNum(x, range, includeMax) {
      var max = range[1];
      range = range[0];
      var d = max - range;
      return x === max && includeMax ? x : ((x - range) % d + d) % d + range;
    }
    function falseFn() {
      return !1;
    }
    function formatNum(num, precision) {
      if (precision === !1) {
        return num;
      }
      precision = Math.pow(10, precision === void 0 ? 6 : precision);
      return Math.round(num * precision) / precision;
    }
    function trim(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
    }
    function splitWords(str) {
      return trim(str).split(/\s+/);
    }
    function setOptions(obj, options) {
      Object.prototype.hasOwnProperty.call(obj, "options") || (obj.options = obj.options ? create$2(obj.options) : {});
      for (var i in options) {
        obj.options[i] = options[i];
      }
      return obj.options;
    }
    function getParamString(obj, existingUrl, uppercase) {
      var params = [], i;
      for (i in obj) {
        params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + "\x3d" + encodeURIComponent(obj[i]));
      }
      return (existingUrl && existingUrl.indexOf("?") !== -1 ? "\x26" : "?") + params.join("\x26");
    }
    function template(str, data) {
      return str.replace(templateRe, function(str, key) {
        key = data[key];
        if (key === void 0) {
          throw Error("No value provided for variable " + str);
        }
        typeof key === "function" && (key = key(data));
        return key;
      });
    }
    function indexOf(array, el) {
      for (var i = 0; i < array.length; i++) {
        if (array[i] === el) {
          return i;
        }
      }
      return -1;
    }
    function getPrefixed(name) {
      return window["webkit" + name] || window["moz" + name] || window["ms" + name];
    }
    function timeoutDefer(fn) {
      var time = +new Date(), timeToCall = Math.max(0, 16 - (time - lastTime));
      lastTime = time + timeToCall;
      return window.setTimeout(fn, timeToCall);
    }
    function requestAnimFrame(fn, context, immediate) {
      if (immediate && requestFn === timeoutDefer) {
        fn.call(context);
      } else {
        return requestFn.call(window, bind(fn, context));
      }
    }
    function cancelAnimFrame(id) {
      id && cancelFn.call(window, id);
    }
    function Class() {
    }
    function checkDeprecatedMixinEvents(includes) {
      if (typeof L !== "undefined" && L && L.Mixin) {
        includes = isArray(includes) ? includes : [includes];
        for (var i = 0; i < includes.length; i++) {
          includes[i] === L.Mixin.Events && console.warn("Deprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.", Error().stack);
        }
      }
    }
    function Point(x, y, round) {
      this.x = round ? Math.round(x) : x;
      this.y = round ? Math.round(y) : y;
    }
    function toPoint(x, y, round) {
      return x instanceof Point ? x : isArray(x) ? new Point(x[0], x[1]) : x === void 0 || x === null ? x : typeof x === "object" && "x" in x && "y" in x ? new Point(x.x, x.y) : new Point(x, y, round);
    }
    function Bounds(a, b) {
      if (a) {
        a = b ? [a, b] : a;
        b = 0;
        for (var len = a.length; b < len; b++) {
          this.extend(a[b]);
        }
      }
    }
    function toBounds(a, b) {
      return !a || a instanceof Bounds ? a : new Bounds(a, b);
    }
    function LatLngBounds(corner1, corner2) {
      if (corner1) {
        corner1 = corner2 ? [corner1, corner2] : corner1;
        corner2 = 0;
        for (var len = corner1.length; corner2 < len; corner2++) {
          this.extend(corner1[corner2]);
        }
      }
    }
    function toLatLngBounds(a, b) {
      return a instanceof LatLngBounds ? a : new LatLngBounds(a, b);
    }
    function LatLng(lat, lng, alt) {
      if (isNaN(lat) || isNaN(lng)) {
        throw Error("Invalid LatLng object: (" + lat + ", " + lng + ")");
      }
      this.lat = +lat;
      this.lng = +lng;
      alt !== void 0 && (this.alt = +alt);
    }
    function toLatLng(a, b, c) {
      return a instanceof LatLng ? a : isArray(a) && typeof a[0] !== "object" ? a.length === 3 ? new LatLng(a[0], a[1], a[2]) : a.length === 2 ? new LatLng(a[0], a[1]) : null : a === void 0 || a === null ? a : typeof a === "object" && "lat" in a ? new LatLng(a.lat, "lng" in a ? a.lng : a.lon, a.alt) : b === void 0 ? null : new LatLng(a, b, c);
    }
    function Transformation(a, b, c, d) {
      isArray(a) ? (this._a = a[0], this._b = a[1], this._c = a[2], this._d = a[3]) : (this._a = a, this._b = b, this._c = c, this._d = d);
    }
    function toTransformation(a, b, c, d) {
      return new Transformation(a, b, c, d);
    }
    function svgCreate(name) {
      return document.createElementNS("http://www.w3.org/2000/svg", name);
    }
    function pointsToPath(rings, closed) {
      var str = "", len, len2;
      var i = 0;
      for (len = rings.length; i < len; i++) {
        var points = rings[i];
        var j = 0;
        for (len2 = points.length; j < len2; j++) {
          var p = points[j];
          str += (j ? "L" : "M") + p.x + " " + p.y;
        }
        str += closed ? Browser.svg ? "z" : "x" : "";
      }
      return str || "M0 0";
    }
    function userAgentContains(str) {
      return navigator.userAgent.toLowerCase().indexOf(str) >= 0;
    }
    function addPointerListener(obj, type, handler) {
      type !== "touchstart" || _pointerDocListener || (document.addEventListener(POINTER_DOWN, _globalPointerDown, !0), document.addEventListener(POINTER_MOVE, _globalPointerMove, !0), document.addEventListener(POINTER_UP, _globalPointerUp, !0), document.addEventListener(POINTER_CANCEL, _globalPointerUp, !0), _pointerDocListener = !0);
      if (!handle[type]) {
        return console.warn("wrong event specified:", type), falseFn;
      }
      handler = handle[type].bind(this, handler);
      obj.addEventListener(pEvent[type], handler, !1);
      return handler;
    }
    function _globalPointerDown(e) {
      _pointers[e.pointerId] = e;
    }
    function _globalPointerMove(e) {
      _pointers[e.pointerId] && (_pointers[e.pointerId] = e);
    }
    function _globalPointerUp(e) {
      delete _pointers[e.pointerId];
    }
    function _handlePointer(handler, e) {
      if (e.pointerType !== (e.MSPOINTER_TYPE_MOUSE || "mouse")) {
        e.touches = [];
        for (var i in _pointers) {
          e.touches.push(_pointers[i]);
        }
        e.changedTouches = [e];
        handler(e);
      }
    }
    function makeDblclick(event) {
      var newEvent = {}, i;
      for (i in event) {
        var prop = event[i];
        newEvent[i] = prop && prop.bind ? prop.bind(event) : prop;
      }
      newEvent.type = "dblclick";
      newEvent.detail = 2;
      newEvent.isTrusted = !1;
      newEvent._simulated = !0;
      return newEvent;
    }
    function addDoubleTapListener(obj, handler) {
      function simDblclick(e) {
        if (e.detail !== 1) {
          detail = e.detail;
        } else {
          if (e.pointerType !== "mouse" && (!e.sourceCapabilities || e.sourceCapabilities.firesTouchEvents)) {
            var path = getPropagationPath(e);
            if (!path.some(function(el) {
              return el instanceof HTMLLabelElement && el.attributes.for;
            }) || path.some(function(el) {
              return el instanceof HTMLInputElement || el instanceof HTMLSelectElement;
            })) {
              path = Date.now(), path - last <= 200 ? (detail++, detail === 2 && handler(makeDblclick(e))) : detail = 1, last = path;
            }
          }
        }
      }
      obj.addEventListener("dblclick", handler);
      var last = 0, detail;
      obj.addEventListener("click", simDblclick);
      return {dblclick:handler, simDblclick};
    }
    function get(id) {
      return typeof id === "string" ? document.getElementById(id) : id;
    }
    function getStyle(el, style) {
      var value = el.style[style] || el.currentStyle && el.currentStyle[style];
      value && value !== "auto" || !document.defaultView || (value = (el = document.defaultView.getComputedStyle(el, null)) ? el[style] : null);
      return value === "auto" ? null : value;
    }
    function create$1(tagName, className, container) {
      tagName = document.createElement(tagName);
      tagName.className = className || "";
      container && container.appendChild(tagName);
      return tagName;
    }
    function remove(el) {
      var parent = el.parentNode;
      parent && parent.removeChild(el);
    }
    function empty(el) {
      for (; el.firstChild;) {
        el.removeChild(el.firstChild);
      }
    }
    function toFront(el) {
      var parent = el.parentNode;
      parent && parent.lastChild !== el && parent.appendChild(el);
    }
    function toBack(el) {
      var parent = el.parentNode;
      parent && parent.firstChild !== el && parent.insertBefore(el, parent.firstChild);
    }
    function hasClass(el, name) {
      if (el.classList !== void 0) {
        return el.classList.contains(name);
      }
      el = getClass(el);
      return el.length > 0 && (new RegExp("(^|\\s)" + name + "(\\s|$)")).test(el);
    }
    function addClass(el, name) {
      if (el.classList !== void 0) {
        name = splitWords(name);
        for (var i = 0, len = name.length; i < len; i++) {
          el.classList.add(name[i]);
        }
      } else {
        hasClass(el, name) || (i = getClass(el), setClass(el, (i ? i + " " : "") + name));
      }
    }
    function removeClass(el, name) {
      el.classList !== void 0 ? el.classList.remove(name) : setClass(el, trim((" " + getClass(el) + " ").replace(" " + name + " ", " ")));
    }
    function setClass(el, name) {
      el.className.baseVal === void 0 ? el.className = name : el.className.baseVal = name;
    }
    function getClass(el) {
      el.correspondingElement && (el = el.correspondingElement);
      return el.className.baseVal === void 0 ? el.className : el.className.baseVal;
    }
    function setOpacity(el, value) {
      if ("opacity" in el.style) {
        el.style.opacity = value;
      } else if ("filter" in el.style) {
        a: {
          var filter = !1;
          try {
            filter = el.filters.item("DXImageTransform.Microsoft.Alpha");
          } catch (e) {
            if (value === 1) {
              break a;
            }
          }
          value = Math.round(value * 100);
          filter ? (filter.Enabled = value !== 100, filter.Opacity = value) : el.style.filter += " progid:DXImageTransform.Microsoft.Alpha(opacity\x3d" + value + ")";
        }
      }
    }
    function testProp(props) {
      for (var style = document.documentElement.style, i = 0; i < props.length; i++) {
        if (props[i] in style) {
          return props[i];
        }
      }
      return !1;
    }
    function setTransform(el, offset, scale) {
      offset = offset || new Point(0, 0);
      el.style[TRANSFORM] = (Browser.ie3d ? "translate(" + offset.x + "px," + offset.y + "px)" : "translate3d(" + offset.x + "px," + offset.y + "px,0)") + (scale ? " scale(" + scale + ")" : "");
    }
    function setPosition(el, point) {
      el._leaflet_pos = point;
      Browser.any3d ? setTransform(el, point) : (el.style.left = point.x + "px", el.style.top = point.y + "px");
    }
    function getPosition(el) {
      return el._leaflet_pos || new Point(0, 0);
    }
    function disableImageDrag() {
      on(window, "dragstart", preventDefault);
    }
    function enableImageDrag() {
      off(window, "dragstart", preventDefault);
    }
    function preventOutline(element) {
      for (; element.tabIndex === -1;) {
        element = element.parentNode;
      }
      element.style && (restoreOutline(), _outlineElement = element, _outlineStyle = element.style.outlineStyle, element.style.outlineStyle = "none", on(window, "keydown", restoreOutline));
    }
    function restoreOutline() {
      _outlineElement && (_outlineElement.style.outlineStyle = _outlineStyle, _outlineStyle = _outlineElement = void 0, off(window, "keydown", restoreOutline));
    }
    function getSizedParentNode(element) {
      do {
        element = element.parentNode;
      } while (!(element.offsetWidth && element.offsetHeight || element === document.body));
      return element;
    }
    function getScale(element) {
      var rect = element.getBoundingClientRect();
      return {x:rect.width / element.offsetWidth || 1, y:rect.height / element.offsetHeight || 1, boundingClientRect:rect};
    }
    function on(obj, types, fn, context) {
      if (types && typeof types === "object") {
        for (var type in types) {
          addOne(obj, type, types[type], fn);
        }
      } else {
        types = splitWords(types);
        type = 0;
        for (var len = types.length; type < len; type++) {
          addOne(obj, types[type], fn, context);
        }
      }
      return this;
    }
    function off(obj, types, fn, context) {
      if (arguments.length === 1) {
        batchRemove(obj), delete obj[eventsKey];
      } else if (types && typeof types === "object") {
        for (var type in types) {
          removeOne(obj, type, types[type], fn);
        }
      } else {
        if (types = splitWords(types), arguments.length === 2) {
          batchRemove(obj, function(type) {
            return indexOf(types, type) !== -1;
          });
        } else {
          type = 0;
          for (var len = types.length; type < len; type++) {
            removeOne(obj, types[type], fn, context);
          }
        }
      }
      return this;
    }
    function batchRemove(obj, filterFn) {
      for (var id in obj[eventsKey]) {
        var type = id.split(/\d/)[0];
        filterFn && !filterFn(type) || removeOne(obj, type, null, null, id);
      }
    }
    function addOne(obj, type, fn, context) {
      var id = type + stamp(fn) + (context ? "_" + stamp(context) : "");
      if (obj[eventsKey] && obj[eventsKey][id]) {
        return this;
      }
      var handler = function(e) {
        return fn.call(context || obj, e || window.event);
      }, originalHandler = handler;
      !Browser.touchNative && Browser.pointer && type.indexOf("touch") === 0 ? handler = addPointerListener(obj, type, handler) : Browser.touch && type === "dblclick" ? handler = addDoubleTapListener(obj, handler) : "addEventListener" in obj ? type === "touchstart" || type === "touchmove" || type === "wheel" || type === "mousewheel" ? obj.addEventListener(mouseSubst[type] || type, handler, Browser.passiveEvents ? {passive:!1} : !1) : type === "mouseenter" || type === "mouseleave" ? (handler = function(e) {
        e = e || window.event;
        isExternalTarget(obj, e) && originalHandler(e);
      }, obj.addEventListener(mouseSubst[type], handler, !1)) : obj.addEventListener(type, originalHandler, !1) : obj.attachEvent("on" + type, handler);
      obj[eventsKey] = obj[eventsKey] || {};
      obj[eventsKey][id] = handler;
    }
    function removeOne(obj, type, fn, context, id) {
      id = id || type + stamp(fn) + (context ? "_" + stamp(context) : "");
      fn = obj[eventsKey] && obj[eventsKey][id];
      if (!fn) {
        return this;
      }
      !Browser.touchNative && Browser.pointer && type.indexOf("touch") === 0 ? pEvent[type] ? obj.removeEventListener(pEvent[type], fn, !1) : console.warn("wrong event specified:", type) : Browser.touch && type === "dblclick" ? (obj.removeEventListener("dblclick", fn.dblclick), obj.removeEventListener("click", fn.simDblclick)) : "removeEventListener" in obj ? obj.removeEventListener(mouseSubst[type] || type, fn, !1) : obj.detachEvent("on" + type, fn);
      obj[eventsKey][id] = null;
    }
    function stopPropagation(e) {
      e.stopPropagation ? e.stopPropagation() : e.originalEvent ? e.originalEvent._stopped = !0 : e.cancelBubble = !0;
      return this;
    }
    function disableScrollPropagation(el) {
      addOne(el, "wheel", stopPropagation);
      return this;
    }
    function disableClickPropagation(el) {
      on(el, "mousedown touchstart dblclick contextmenu", stopPropagation);
      el._leaflet_disable_click = !0;
      return this;
    }
    function preventDefault(e) {
      e.preventDefault ? e.preventDefault() : e.returnValue = !1;
      return this;
    }
    function stop(e) {
      preventDefault(e);
      stopPropagation(e);
      return this;
    }
    function getPropagationPath(ev) {
      if (ev.composedPath) {
        return ev.composedPath();
      }
      var path = [];
      for (ev = ev.target; ev;) {
        path.push(ev), ev = ev.parentNode;
      }
      return path;
    }
    function getMousePosition(e, container) {
      if (!container) {
        return new Point(e.clientX, e.clientY);
      }
      var scale = getScale(container), offset = scale.boundingClientRect;
      return new Point((e.clientX - offset.left) / scale.x - container.clientLeft, (e.clientY - offset.top) / scale.y - container.clientTop);
    }
    function getWheelDelta(e) {
      return Browser.edge ? e.wheelDeltaY / 2 : e.deltaY && e.deltaMode === 0 ? -e.deltaY / wheelPxFactor : e.deltaY && e.deltaMode === 1 ? -e.deltaY * 20 : e.deltaY && e.deltaMode === 2 ? -e.deltaY * 60 : e.deltaX || e.deltaZ ? 0 : e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : e.detail && Math.abs(e.detail) < 32765 ? -e.detail * 20 : e.detail ? e.detail / -32765 * 60 : 0;
    }
    function isExternalTarget(el, e) {
      e = e.relatedTarget;
      if (!e) {
        return !0;
      }
      try {
        for (; e && e !== el;) {
          e = e.parentNode;
        }
      } catch (err) {
        return !1;
      }
      return e !== el;
    }
    function clipPolygon(points, bounds, round) {
      var edges = [1, 4, 2, 8], j, k, len;
      var i = 0;
      for (len = points.length; i < len; i++) {
        points[i]._code = _getBitCode(points[i], bounds);
      }
      for (k = 0; k < 4; k++) {
        var edge = edges[k];
        var clippedPoints = [];
        i = 0;
        len = points.length;
        for (j = len - 1; i < len; j = i++) {
          var a = points[i];
          j = points[j];
          a._code & edge ? j._code & edge || (j = _getEdgeIntersection(j, a, edge, bounds, round), j._code = _getBitCode(j, bounds), clippedPoints.push(j)) : (j._code & edge && (j = _getEdgeIntersection(j, a, edge, bounds, round), j._code = _getBitCode(j, bounds), clippedPoints.push(j)), clippedPoints.push(a));
        }
        points = clippedPoints;
      }
      return points;
    }
    function polygonCenter(latlngs, crs) {
      var j, x, y;
      if (!latlngs || latlngs.length === 0) {
        throw Error("latlngs not passed");
      }
      isFlat(latlngs) || (console.warn("latlngs are not flat! Only the first ring will be used"), latlngs = latlngs[0]);
      var centroidLatLng = toLatLng([0, 0]);
      var i = toLatLngBounds(latlngs);
      i.getNorthWest().distanceTo(i.getSouthWest()) * i.getNorthEast().distanceTo(i.getNorthWest()) < 1700 && (centroidLatLng = centroid(latlngs));
      var len = latlngs.length, points = [];
      for (i = 0; i < len; i++) {
        var area = toLatLng(latlngs[i]);
        points.push(crs.project(toLatLng([area.lat - centroidLatLng.lat, area.lng - centroidLatLng.lng])));
      }
      i = area = x = y = 0;
      for (j = len - 1; i < len; j = i++) {
        latlngs = points[i];
        j = points[j];
        var f = latlngs.y * j.x - j.y * latlngs.x;
        x += (latlngs.x + j.x) * f;
        y += (latlngs.y + j.y) * f;
        area += f * 3;
      }
      crs = crs.unproject(toPoint(area === 0 ? points[0] : [x / area, y / area]));
      return toLatLng([crs.lat + centroidLatLng.lat, crs.lng + centroidLatLng.lng]);
    }
    function centroid(coords) {
      for (var latSum = 0, lngSum = 0, len = 0, i = 0; i < coords.length; i++) {
        var latlng = toLatLng(coords[i]);
        latSum += latlng.lat;
        lngSum += latlng.lng;
        len++;
      }
      return toLatLng([latSum / len, lngSum / len]);
    }
    function simplify(points, tolerance) {
      if (!tolerance || !points.length) {
        return points.slice();
      }
      tolerance *= tolerance;
      for (var reducedPoints = [points[0]], i = 1, prev = 0, len = points.length; i < len; i++) {
        var p1 = points[i], p2 = points[prev], dx = p2.x - p1.x;
        p1 = p2.y - p1.y;
        dx * dx + p1 * p1 > tolerance && (reducedPoints.push(points[i]), prev = i);
      }
      prev < len - 1 && reducedPoints.push(points[len - 1]);
      points = reducedPoints;
      reducedPoints = points.length;
      i = new (typeof Uint8Array !== "undefined" ? Uint8Array : Array)(reducedPoints);
      i[0] = i[reducedPoints - 1] = 1;
      _simplifyDPStep(points, i, tolerance, 0, reducedPoints - 1);
      prev = [];
      for (tolerance = 0; tolerance < reducedPoints; tolerance++) {
        i[tolerance] && prev.push(points[tolerance]);
      }
      return points = prev;
    }
    function pointToSegmentDistance(p, p1, p2) {
      return Math.sqrt(_sqClosestPointOnSegment(p, p1, p2, !0));
    }
    function _simplifyDPStep(points, markers, sqTolerance, first, last) {
      var maxSqDist = 0, i;
      for (i = first + 1; i <= last - 1; i++) {
        var sqDist = _sqClosestPointOnSegment(points[i], points[first], points[last], !0);
        if (sqDist > maxSqDist) {
          var index = i;
          maxSqDist = sqDist;
        }
      }
      maxSqDist > sqTolerance && (markers[index] = 1, _simplifyDPStep(points, markers, sqTolerance, first, index), _simplifyDPStep(points, markers, sqTolerance, index, last));
    }
    function clipSegment(a, b, bounds, useLastCode, round) {
      useLastCode = useLastCode ? _lastCode : _getBitCode(a, bounds);
      var codeB = _getBitCode(b, bounds);
      for (_lastCode = codeB;;) {
        if (!(useLastCode | codeB)) {
          return [a, b];
        }
        if (useLastCode & codeB) {
          return !1;
        }
        var codeOut = useLastCode || codeB;
        var p = _getEdgeIntersection(a, b, codeOut, bounds, round);
        var newCode = _getBitCode(p, bounds);
        codeOut === useLastCode ? (a = p, useLastCode = newCode) : (b = p, codeB = newCode);
      }
    }
    function _getEdgeIntersection(a, b, code, bounds, round) {
      var dx = b.x - a.x;
      b = b.y - a.y;
      var min = bounds.min;
      bounds = bounds.max;
      if (code & 8) {
        var x = a.x + dx * (bounds.y - a.y) / b;
        var y = bounds.y;
      } else {
        code & 4 ? (x = a.x + dx * (min.y - a.y) / b, y = min.y) : code & 2 ? (x = bounds.x, y = a.y + b * (bounds.x - a.x) / dx) : code & 1 && (x = min.x, y = a.y + b * (min.x - a.x) / dx);
      }
      return new Point(x, y, round);
    }
    function _getBitCode(p, bounds) {
      var code = 0;
      p.x < bounds.min.x ? code |= 1 : p.x > bounds.max.x && (code |= 2);
      p.y < bounds.min.y ? code |= 4 : p.y > bounds.max.y && (code |= 8);
      return code;
    }
    function _sqClosestPointOnSegment(p, p1, p2, sqDist) {
      var x = p1.x;
      p1 = p1.y;
      var dx = p2.x - x, dy = p2.y - p1, dot = dx * dx + dy * dy;
      dot > 0 && (dot = ((p.x - x) * dx + (p.y - p1) * dy) / dot, dot > 1 ? (x = p2.x, p1 = p2.y) : dot > 0 && (x += dx * dot, p1 += dy * dot));
      dx = p.x - x;
      dy = p.y - p1;
      return sqDist ? dx * dx + dy * dy : new Point(x, p1);
    }
    function isFlat(latlngs) {
      return !isArray(latlngs[0]) || typeof latlngs[0][0] !== "object" && typeof latlngs[0][0] !== "undefined";
    }
    function _flat(latlngs) {
      console.warn("Deprecated use of _flat, please use L.LineUtil.isFlat instead.");
      return isFlat(latlngs);
    }
    function polylineCenter(latlngs, crs) {
      var halfDist, dist;
      if (!latlngs || latlngs.length === 0) {
        throw Error("latlngs not passed");
      }
      isFlat(latlngs) || (console.warn("latlngs are not flat! Only the first ring will be used"), latlngs = latlngs[0]);
      var centroidLatLng = toLatLng([0, 0]);
      var i = toLatLngBounds(latlngs);
      i.getNorthWest().distanceTo(i.getSouthWest()) * i.getNorthEast().distanceTo(i.getNorthWest()) < 1700 && (centroidLatLng = centroid(latlngs));
      var len = latlngs.length, points = [];
      for (i = 0; i < len; i++) {
        var p2 = toLatLng(latlngs[i]);
        points.push(crs.project(toLatLng([p2.lat - centroidLatLng.lat, p2.lng - centroidLatLng.lng])));
      }
      for (halfDist = i = 0; i < len - 1; i++) {
        halfDist += points[i].distanceTo(points[i + 1]) / 2;
      }
      if (halfDist === 0) {
        var ratio = points[0];
      } else {
        for (dist = i = 0; i < len - 1; i++) {
          latlngs = points[i];
          p2 = points[i + 1];
          var segDist = latlngs.distanceTo(p2);
          dist += segDist;
          if (dist > halfDist) {
            ratio = (dist - halfDist) / segDist;
            ratio = [p2.x - ratio * (p2.x - latlngs.x), p2.y - ratio * (p2.y - latlngs.y)];
            break;
          }
        }
      }
      crs = crs.unproject(toPoint(ratio));
      return toLatLng([crs.lat + centroidLatLng.lat, crs.lng + centroidLatLng.lng]);
    }
    function geometryToLayer(geojson$jscomp$0, options$jscomp$0) {
      var geometry = geojson$jscomp$0.type === "Feature" ? geojson$jscomp$0.geometry : geojson$jscomp$0, coords = geometry ? geometry.coordinates : null, layers = [], pointToLayer = options$jscomp$0 && options$jscomp$0.pointToLayer, _coordsToLatLng = options$jscomp$0 && options$jscomp$0.coordsToLatLng || coordsToLatLng, latlng, len;
      if (!coords && !geometry) {
        return null;
      }
      switch(geometry.type) {
        case "Point":
          return layers = latlng = _coordsToLatLng(coords), pointToLayer ? pointToLayer(geojson$jscomp$0, layers) : new Marker(layers, options$jscomp$0 && options$jscomp$0.markersInheritOptions && options$jscomp$0);
        case "MultiPoint":
          var i = 0;
          for (len = coords.length; i < len; i++) {
            latlng = _coordsToLatLng(coords[i]);
            geometry = layers;
            var JSCompiler_temp_const = geometry.push;
            var JSCompiler_inline_result = pointToLayer;
            var geojson = geojson$jscomp$0, options = options$jscomp$0;
            JSCompiler_inline_result = JSCompiler_inline_result ? JSCompiler_inline_result(geojson, latlng) : new Marker(latlng, options && options.markersInheritOptions && options);
            JSCompiler_temp_const.call(geometry, JSCompiler_inline_result);
          }
          return new FeatureGroup(layers);
        case "LineString":
        case "MultiLineString":
          return geojson$jscomp$0 = coordsToLatLngs(coords, geometry.type === "LineString" ? 0 : 1, _coordsToLatLng), new Polyline(geojson$jscomp$0, options$jscomp$0);
        case "Polygon":
        case "MultiPolygon":
          return geojson$jscomp$0 = coordsToLatLngs(coords, geometry.type === "Polygon" ? 1 : 2, _coordsToLatLng), new Polygon(geojson$jscomp$0, options$jscomp$0);
        case "GeometryCollection":
          i = 0;
          for (len = geometry.geometries.length; i < len; i++) {
            (pointToLayer = geometryToLayer({geometry:geometry.geometries[i], type:"Feature", properties:geojson$jscomp$0.properties}, options$jscomp$0)) && layers.push(pointToLayer);
          }
          return new FeatureGroup(layers);
        case "FeatureCollection":
          i = 0;
          for (len = geometry.features.length; i < len; i++) {
            (geojson$jscomp$0 = geometryToLayer(geometry.features[i], options$jscomp$0)) && layers.push(geojson$jscomp$0);
          }
          return new FeatureGroup(layers);
        default:
          throw Error("Invalid GeoJSON object.");
      }
    }
    function coordsToLatLng(coords) {
      return new LatLng(coords[1], coords[0], coords[2]);
    }
    function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {
      for (var latlngs = [], i = 0, len = coords.length, latlng; i < len; i++) {
        latlng = levelsDeep ? coordsToLatLngs(coords[i], levelsDeep - 1, _coordsToLatLng) : (_coordsToLatLng || coordsToLatLng)(coords[i]), latlngs.push(latlng);
      }
      return latlngs;
    }
    function latLngToCoords(latlng, precision) {
      latlng = toLatLng(latlng);
      return latlng.alt !== void 0 ? [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision), formatNum(latlng.alt, precision)] : [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision)];
    }
    function latLngsToCoords(latlngs, levelsDeep, closed, precision) {
      for (var coords = [], i = 0, len = latlngs.length; i < len; i++) {
        coords.push(levelsDeep ? latLngsToCoords(latlngs[i], isFlat(latlngs[i]) ? 0 : levelsDeep - 1, closed, precision) : latLngToCoords(latlngs[i], precision));
      }
      !levelsDeep && closed && coords.length > 0 && coords.push(coords[0].slice());
      return coords;
    }
    function getFeature(layer, newGeometry) {
      return layer.feature ? extend({}, layer.feature, {geometry:newGeometry}) : asFeature(newGeometry);
    }
    function asFeature(geojson) {
      return geojson.type === "Feature" || geojson.type === "FeatureCollection" ? geojson : {type:"Feature", properties:{}, geometry:geojson};
    }
    function geoJSON(geojson, options) {
      return new GeoJSON(geojson, options);
    }
    function tileLayer(url, options) {
      return new TileLayer(url, options);
    }
    function canvas(options) {
      return Browser.canvas ? new Canvas(options) : null;
    }
    function svg(options) {
      return Browser.svg || Browser.vml ? new SVG(options) : null;
    }
    var create$2 = Object.create || function() {
      function F() {
      }
      return function(proto) {
        F.prototype = proto;
        return new F();
      };
    }(), lastId = 0, templateRe = /\{ *([\w_ -]+) *\}/g, isArray = Array.isArray || function(obj) {
      return Object.prototype.toString.call(obj) === "[object Array]";
    }, lastTime = 0, requestFn = window.requestAnimationFrame || getPrefixed("RequestAnimationFrame") || timeoutDefer, cancelFn = window.cancelAnimationFrame || getPrefixed("CancelAnimationFrame") || getPrefixed("CancelRequestAnimationFrame") || function(id) {
      window.clearTimeout(id);
    }, Util = {__proto__:null, extend, create:create$2, bind, get lastId() {
      return lastId;
    }, stamp, throttle, wrapNum, falseFn, formatNum, trim, splitWords, setOptions, getParamString, template, isArray, indexOf, emptyImageUrl:"data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs\x3d", requestFn, cancelFn, requestAnimFrame, cancelAnimFrame};
    Class.extend = function(props) {
      var NewClass = function() {
        setOptions(this);
        this.initialize && this.initialize.apply(this, arguments);
        this.callInitHooks();
      }, parentProto = NewClass.__super__ = this.prototype, proto = create$2(parentProto);
      proto.constructor = NewClass;
      NewClass.prototype = proto;
      for (var i in this) {
        Object.prototype.hasOwnProperty.call(this, i) && i !== "prototype" && i !== "__super__" && (NewClass[i] = this[i]);
      }
      props.statics && extend(NewClass, props.statics);
      props.includes && (checkDeprecatedMixinEvents(props.includes), extend.apply(null, [proto].concat(props.includes)));
      extend(proto, props);
      delete proto.statics;
      delete proto.includes;
      proto.options && (proto.options = parentProto.options ? create$2(parentProto.options) : {}, extend(proto.options, props.options));
      proto._initHooks = [];
      proto.callInitHooks = function() {
        if (!this._initHooksCalled) {
          parentProto.callInitHooks && parentProto.callInitHooks.call(this);
          this._initHooksCalled = !0;
          for (var i = 0, len = proto._initHooks.length; i < len; i++) {
            proto._initHooks[i].call(this);
          }
        }
      };
      return NewClass;
    };
    Class.include = function(props) {
      var parentOptions = this.prototype.options;
      extend(this.prototype, props);
      props.options && (this.prototype.options = parentOptions, this.mergeOptions(props.options));
      return this;
    };
    Class.mergeOptions = function(options) {
      extend(this.prototype.options, options);
      return this;
    };
    Class.addInitHook = function(fn) {
      var args = Array.prototype.slice.call(arguments, 1);
      this.prototype._initHooks = this.prototype._initHooks || [];
      this.prototype._initHooks.push(typeof fn === "function" ? fn : function() {
        this[fn].apply(this, args);
      });
      return this;
    };
    var Events = {on:function(types, fn, context) {
      if (typeof types === "object") {
        for (var type in types) {
          this._on(type, types[type], fn);
        }
      } else {
        types = splitWords(types);
        type = 0;
        for (var len = types.length; type < len; type++) {
          this._on(types[type], fn, context);
        }
      }
      return this;
    }, off:function(types, fn, context) {
      if (arguments.length) {
        if (typeof types === "object") {
          for (var type in types) {
            this._off(type, types[type], fn);
          }
        } else {
          types = splitWords(types);
          type = arguments.length === 1;
          for (var i = 0, len = types.length; i < len; i++) {
            type ? this._off(types[i]) : this._off(types[i], fn, context);
          }
        }
      } else {
        delete this._events;
      }
      return this;
    }, _on:function(type, fn, context, _once) {
      typeof fn !== "function" ? console.warn("wrong listener type: " + typeof fn) : this._listens(type, fn, context) === !1 && (context === this && (context = void 0), fn = {fn, ctx:context}, _once && (fn.once = !0), this._events = this._events || {}, this._events[type] = this._events[type] || [], this._events[type].push(fn));
    }, _off:function(type, fn, context) {
      var listeners, len;
      if (this._events && (listeners = this._events[type])) {
        if (arguments.length === 1) {
          if (this._firingCount) {
            var i = 0;
            for (len = listeners.length; i < len; i++) {
              listeners[i].fn = falseFn;
            }
          }
          delete this._events[type];
        } else {
          typeof fn !== "function" ? console.warn("wrong listener type: " + typeof fn) : (i = this._listens(type, fn, context), i !== !1 && (len = listeners[i], this._firingCount && (len.fn = falseFn, this._events[type] = listeners = listeners.slice()), listeners.splice(i, 1)));
        }
      }
    }, fire:function(type, data, propagate) {
      if (!this.listens(type, propagate)) {
        return this;
      }
      data = extend({}, data, {type, target:this, sourceTarget:data && data.sourceTarget || this});
      if (this._events) {
        var listeners = this._events[type];
        if (listeners) {
          this._firingCount = this._firingCount + 1 || 1;
          for (var i = 0, len = listeners.length; i < len; i++) {
            var l = listeners[i], fn = l.fn;
            l.once && this.off(type, fn, l.ctx);
            fn.call(l.ctx || this, data);
          }
          this._firingCount--;
        }
      }
      propagate && this._propagateEvent(data);
      return this;
    }, listens:function(type, fn, context, propagate) {
      typeof type !== "string" && console.warn('"string" type argument expected');
      var _fn = fn;
      typeof fn !== "function" && (propagate = !!fn, context = _fn = void 0);
      var listeners = this._events && this._events[type];
      if (listeners && listeners.length && this._listens(type, _fn, context) !== !1) {
        return !0;
      }
      if (propagate) {
        for (var id in this._eventParents) {
          if (this._eventParents[id].listens(type, fn, context, propagate)) {
            return !0;
          }
        }
      }
      return !1;
    }, _listens:function(type, fn, context) {
      if (!this._events) {
        return !1;
      }
      type = this._events[type] || [];
      if (!fn) {
        return !!type.length;
      }
      context === this && (context = void 0);
      for (var i = 0, len = type.length; i < len; i++) {
        if (type[i].fn === fn && type[i].ctx === context) {
          return i;
        }
      }
      return !1;
    }, once:function(types, fn, context) {
      if (typeof types === "object") {
        for (var type in types) {
          this._on(type, types[type], fn, !0);
        }
      } else {
        types = splitWords(types);
        type = 0;
        for (var len = types.length; type < len; type++) {
          this._on(types[type], fn, context, !0);
        }
      }
      return this;
    }, addEventParent:function(obj) {
      this._eventParents = this._eventParents || {};
      this._eventParents[stamp(obj)] = obj;
      return this;
    }, removeEventParent:function(obj) {
      this._eventParents && delete this._eventParents[stamp(obj)];
      return this;
    }, _propagateEvent:function(e) {
      for (var id in this._eventParents) {
        this._eventParents[id].fire(e.type, extend({layer:e.target, propagatedFrom:e.target}, e), !0);
      }
    }};
    Events.addEventListener = Events.on;
    Events.removeEventListener = Events.clearAllEventListeners = Events.off;
    Events.addOneTimeEventListener = Events.once;
    Events.fireEvent = Events.fire;
    Events.hasEventListeners = Events.listens;
    var Evented = Class.extend(Events), trunc = Math.trunc || function(v) {
      return v > 0 ? Math.floor(v) : Math.ceil(v);
    };
    Point.prototype = {clone:function() {
      return new Point(this.x, this.y);
    }, add:function(point) {
      return this.clone()._add(toPoint(point));
    }, _add:function(point) {
      this.x += point.x;
      this.y += point.y;
      return this;
    }, subtract:function(point) {
      return this.clone()._subtract(toPoint(point));
    }, _subtract:function(point) {
      this.x -= point.x;
      this.y -= point.y;
      return this;
    }, divideBy:function(num) {
      return this.clone()._divideBy(num);
    }, _divideBy:function(num) {
      this.x /= num;
      this.y /= num;
      return this;
    }, multiplyBy:function(num) {
      return this.clone()._multiplyBy(num);
    }, _multiplyBy:function(num) {
      this.x *= num;
      this.y *= num;
      return this;
    }, scaleBy:function(point) {
      return new Point(this.x * point.x, this.y * point.y);
    }, unscaleBy:function(point) {
      return new Point(this.x / point.x, this.y / point.y);
    }, round:function() {
      return this.clone()._round();
    }, _round:function() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      return this;
    }, floor:function() {
      return this.clone()._floor();
    }, _floor:function() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      return this;
    }, ceil:function() {
      return this.clone()._ceil();
    }, _ceil:function() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      return this;
    }, trunc:function() {
      return this.clone()._trunc();
    }, _trunc:function() {
      this.x = trunc(this.x);
      this.y = trunc(this.y);
      return this;
    }, distanceTo:function(point) {
      point = toPoint(point);
      var x = point.x - this.x;
      point = point.y - this.y;
      return Math.sqrt(x * x + point * point);
    }, equals:function(point) {
      point = toPoint(point);
      return point.x === this.x && point.y === this.y;
    }, contains:function(point) {
      point = toPoint(point);
      return Math.abs(point.x) <= Math.abs(this.x) && Math.abs(point.y) <= Math.abs(this.y);
    }, toString:function() {
      return "Point(" + formatNum(this.x) + ", " + formatNum(this.y) + ")";
    }};
    Bounds.prototype = {extend:function(obj) {
      if (!obj) {
        return this;
      }
      if (obj instanceof Point || typeof obj[0] === "number" || "x" in obj) {
        var min2 = obj = toPoint(obj);
      } else {
        if (obj = toBounds(obj), min2 = obj.min, obj = obj.max, !min2 || !obj) {
          return this;
        }
      }
      this.min || this.max ? (this.min.x = Math.min(min2.x, this.min.x), this.max.x = Math.max(obj.x, this.max.x), this.min.y = Math.min(min2.y, this.min.y), this.max.y = Math.max(obj.y, this.max.y)) : (this.min = min2.clone(), this.max = obj.clone());
      return this;
    }, getCenter:function(round) {
      return toPoint((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, round);
    }, getBottomLeft:function() {
      return toPoint(this.min.x, this.max.y);
    }, getTopRight:function() {
      return toPoint(this.max.x, this.min.y);
    }, getTopLeft:function() {
      return this.min;
    }, getBottomRight:function() {
      return this.max;
    }, getSize:function() {
      return this.max.subtract(this.min);
    }, contains:function(obj) {
      obj = typeof obj[0] === "number" || obj instanceof Point ? toPoint(obj) : toBounds(obj);
      if (obj instanceof Bounds) {
        var min = obj.min;
        obj = obj.max;
      } else {
        min = obj;
      }
      return min.x >= this.min.x && obj.x <= this.max.x && min.y >= this.min.y && obj.y <= this.max.y;
    }, intersects:function(bounds) {
      bounds = toBounds(bounds);
      var min = this.min, max = this.max, min2 = bounds.min;
      bounds = bounds.max;
      var yIntersects = bounds.y >= min.y && min2.y <= max.y;
      return bounds.x >= min.x && min2.x <= max.x && yIntersects;
    }, overlaps:function(bounds) {
      bounds = toBounds(bounds);
      var min = this.min, max = this.max, min2 = bounds.min;
      bounds = bounds.max;
      var yOverlaps = bounds.y > min.y && min2.y < max.y;
      return bounds.x > min.x && min2.x < max.x && yOverlaps;
    }, isValid:function() {
      return !(!this.min || !this.max);
    }, pad:function(bufferRatio) {
      var min = this.min, max = this.max, heightBuffer = Math.abs(min.x - max.x) * bufferRatio;
      bufferRatio *= Math.abs(min.y - max.y);
      return toBounds(toPoint(min.x - heightBuffer, min.y - bufferRatio), toPoint(max.x + heightBuffer, max.y + bufferRatio));
    }, equals:function(bounds) {
      if (!bounds) {
        return !1;
      }
      bounds = toBounds(bounds);
      return this.min.equals(bounds.getTopLeft()) && this.max.equals(bounds.getBottomRight());
    }};
    LatLngBounds.prototype = {extend:function(obj) {
      var sw = this._southWest, ne = this._northEast;
      if (obj instanceof LatLng) {
        var sw2 = obj;
      } else if (obj instanceof LatLngBounds) {
        if (sw2 = obj._southWest, obj = obj._northEast, !sw2 || !obj) {
          return this;
        }
      } else {
        return obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;
      }
      sw || ne ? (sw.lat = Math.min(sw2.lat, sw.lat), sw.lng = Math.min(sw2.lng, sw.lng), ne.lat = Math.max(obj.lat, ne.lat), ne.lng = Math.max(obj.lng, ne.lng)) : (this._southWest = new LatLng(sw2.lat, sw2.lng), this._northEast = new LatLng(obj.lat, obj.lng));
      return this;
    }, pad:function(bufferRatio) {
      var sw = this._southWest, ne = this._northEast, heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio;
      bufferRatio *= Math.abs(sw.lng - ne.lng);
      return new LatLngBounds(new LatLng(sw.lat - heightBuffer, sw.lng - bufferRatio), new LatLng(ne.lat + heightBuffer, ne.lng + bufferRatio));
    }, getCenter:function() {
      return new LatLng((this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2);
    }, getSouthWest:function() {
      return this._southWest;
    }, getNorthEast:function() {
      return this._northEast;
    }, getNorthWest:function() {
      return new LatLng(this.getNorth(), this.getWest());
    }, getSouthEast:function() {
      return new LatLng(this.getSouth(), this.getEast());
    }, getWest:function() {
      return this._southWest.lng;
    }, getSouth:function() {
      return this._southWest.lat;
    }, getEast:function() {
      return this._northEast.lng;
    }, getNorth:function() {
      return this._northEast.lat;
    }, contains:function(obj) {
      obj = typeof obj[0] === "number" || obj instanceof LatLng || "lat" in obj ? toLatLng(obj) : toLatLngBounds(obj);
      var sw = this._southWest, ne = this._northEast;
      if (obj instanceof LatLngBounds) {
        var sw2 = obj.getSouthWest();
        obj = obj.getNorthEast();
      } else {
        sw2 = obj;
      }
      return sw2.lat >= sw.lat && obj.lat <= ne.lat && sw2.lng >= sw.lng && obj.lng <= ne.lng;
    }, intersects:function(bounds) {
      bounds = toLatLngBounds(bounds);
      var sw = this._southWest, ne = this._northEast, sw2 = bounds.getSouthWest();
      bounds = bounds.getNorthEast();
      var lngIntersects = bounds.lng >= sw.lng && sw2.lng <= ne.lng;
      return bounds.lat >= sw.lat && sw2.lat <= ne.lat && lngIntersects;
    }, overlaps:function(bounds) {
      bounds = toLatLngBounds(bounds);
      var sw = this._southWest, ne = this._northEast, sw2 = bounds.getSouthWest();
      bounds = bounds.getNorthEast();
      var lngOverlaps = bounds.lng > sw.lng && sw2.lng < ne.lng;
      return bounds.lat > sw.lat && sw2.lat < ne.lat && lngOverlaps;
    }, toBBoxString:function() {
      return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join();
    }, equals:function(bounds, maxMargin) {
      if (!bounds) {
        return !1;
      }
      bounds = toLatLngBounds(bounds);
      return this._southWest.equals(bounds.getSouthWest(), maxMargin) && this._northEast.equals(bounds.getNorthEast(), maxMargin);
    }, isValid:function() {
      return !(!this._southWest || !this._northEast);
    }};
    LatLng.prototype = {equals:function(obj, maxMargin) {
      if (!obj) {
        return !1;
      }
      obj = toLatLng(obj);
      return Math.max(Math.abs(this.lat - obj.lat), Math.abs(this.lng - obj.lng)) <= (maxMargin === void 0 ? 1.0E-9 : maxMargin);
    }, toString:function(precision) {
      return "LatLng(" + formatNum(this.lat, precision) + ", " + formatNum(this.lng, precision) + ")";
    }, distanceTo:function(other) {
      return Earth.distance(this, toLatLng(other));
    }, wrap:function() {
      return Earth.wrapLatLng(this);
    }, toBounds:function(sizeInMeters) {
      sizeInMeters = 180 * sizeInMeters / 40075017;
      var lngAccuracy = sizeInMeters / Math.cos(Math.PI / 180 * this.lat);
      return toLatLngBounds([this.lat - sizeInMeters, this.lng - lngAccuracy], [this.lat + sizeInMeters, this.lng + lngAccuracy]);
    }, clone:function() {
      return new LatLng(this.lat, this.lng, this.alt);
    }};
    var CRS = {latLngToPoint:function(latlng, zoom) {
      latlng = this.projection.project(latlng);
      zoom = this.scale(zoom);
      return this.transformation._transform(latlng, zoom);
    }, pointToLatLng:function(point, zoom) {
      zoom = this.scale(zoom);
      point = this.transformation.untransform(point, zoom);
      return this.projection.unproject(point);
    }, project:function(latlng) {
      return this.projection.project(latlng);
    }, unproject:function(point) {
      return this.projection.unproject(point);
    }, scale:function(zoom) {
      return 256 * Math.pow(2, zoom);
    }, zoom:function(scale) {
      return Math.log(scale / 256) / Math.LN2;
    }, getProjectedBounds:function(zoom) {
      if (this.infinite) {
        return null;
      }
      var b = this.projection.bounds, s = this.scale(zoom);
      zoom = this.transformation.transform(b.min, s);
      b = this.transformation.transform(b.max, s);
      return new Bounds(zoom, b);
    }, infinite:!1, wrapLatLng:function(latlng) {
      var lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, !0) : latlng.lng, lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, !0) : latlng.lat;
      return new LatLng(lat, lng, latlng.alt);
    }, wrapLatLngBounds:function(bounds) {
      var center = bounds.getCenter(), newCenter = this.wrapLatLng(center), latShift = center.lat - newCenter.lat;
      center = center.lng - newCenter.lng;
      if (latShift === 0 && center === 0) {
        return bounds;
      }
      newCenter = bounds.getSouthWest();
      bounds = bounds.getNorthEast();
      newCenter = new LatLng(newCenter.lat - latShift, newCenter.lng - center);
      latShift = new LatLng(bounds.lat - latShift, bounds.lng - center);
      return new LatLngBounds(newCenter, latShift);
    }}, Earth = extend({}, CRS, {wrapLng:[-180, 180], R:6371000, distance:function(latlng1, latlng2) {
      var rad = Math.PI / 180, sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2), sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2);
      latlng1 = sinDLat * sinDLat + Math.cos(latlng1.lat * rad) * Math.cos(latlng2.lat * rad) * sinDLon * sinDLon;
      return 2 * Math.atan2(Math.sqrt(latlng1), Math.sqrt(1 - latlng1)) * this.R;
    }}), SphericalMercator = {R:6378137, MAX_LATITUDE:85.0511287798, project:function(latlng) {
      var d = Math.PI / 180, max = this.MAX_LATITUDE;
      max = Math.sin(Math.max(Math.min(max, latlng.lat), -max) * d);
      return new Point(this.R * latlng.lng * d, this.R * Math.log((1 + max) / (1 - max)) / 2);
    }, unproject:function(point) {
      var d = 180 / Math.PI;
      return new LatLng((2 * Math.atan(Math.exp(point.y / this.R)) - Math.PI / 2) * d, point.x * d / this.R);
    }, bounds:function() {
      var d = 6378137 * Math.PI;
      return new Bounds([-d, -d], [d, d]);
    }()};
    Transformation.prototype = {transform:function(point, scale) {
      return this._transform(point.clone(), scale);
    }, _transform:function(point, scale) {
      scale = scale || 1;
      point.x = scale * (this._a * point.x + this._b);
      point.y = scale * (this._c * point.y + this._d);
      return point;
    }, untransform:function(point, scale) {
      scale = scale || 1;
      return new Point((point.x / scale - this._b) / this._a, (point.y / scale - this._d) / this._c);
    }};
    var EPSG3857 = extend({}, Earth, {code:"EPSG:3857", projection:SphericalMercator, transformation:function() {
      var scale = 0.5 / (Math.PI * SphericalMercator.R);
      return toTransformation(scale, 0.5, -scale, 0.5);
    }()}), EPSG900913 = extend({}, EPSG3857, {code:"EPSG:900913"}), style = document.documentElement.style, ie = "ActiveXObject" in window, ielt9 = ie && !document.addEventListener, edge = "msLaunchUri" in navigator && !("documentMode" in document), webkit = userAgentContains("webkit"), android = userAgentContains("android"), android23 = userAgentContains("android 2") || userAgentContains("android 3"), webkitVer = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10), androidStock = android && 
    userAgentContains("Google") && webkitVer < 537 && !("AudioNode" in window), opera = !!window.opera, chrome = !edge && userAgentContains("chrome"), gecko = userAgentContains("gecko") && !webkit && !opera && !ie, safari = !chrome && userAgentContains("safari"), phantom = userAgentContains("phantom"), opera12 = "OTransition" in style, win = navigator.platform.indexOf("Win") === 0, ie3d = ie && "transition" in style, webkit3d = "WebKitCSSMatrix" in window && "m11" in new window.WebKitCSSMatrix() && 
    !android23, gecko3d = "MozPerspective" in style, any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom, mobile = typeof orientation !== "undefined" || userAgentContains("mobile"), mobileWebkit = mobile && webkit, mobileWebkit3d = mobile && webkit3d, msPointer = !window.PointerEvent && window.MSPointerEvent, pointer = !(!window.PointerEvent && !msPointer), touchNative = "ontouchstart" in window || !!window.TouchEvent, touch = !window.L_NO_TOUCH && (touchNative || 
    pointer), mobileOpera = mobile && opera, mobileGecko = mobile && gecko, retina = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1, passiveEvents = function() {
      var supportsPassiveOption = !1;
      try {
        var opts = Object.defineProperty({}, "passive", {get:function() {
          supportsPassiveOption = !0;
        }});
        window.addEventListener("testPassiveEventSupport", falseFn, opts);
        window.removeEventListener("testPassiveEventSupport", falseFn, opts);
      } catch (e) {
      }
      return supportsPassiveOption;
    }(), canvas$1 = !!document.createElement("canvas").getContext, svg$1 = !(!document.createElementNS || !svgCreate("svg").createSVGRect), inlineSvg = !!svg$1 && function() {
      var div = document.createElement("div");
      div.innerHTML = "\x3csvg/\x3e";
      return (div.firstChild && div.firstChild.namespaceURI) === "http://www.w3.org/2000/svg";
    }(), vml = !svg$1 && function() {
      try {
        var div = document.createElement("div");
        div.innerHTML = '\x3cv:shape adj\x3d"1"/\x3e';
        var shape = div.firstChild;
        shape.style.behavior = "url(#default#VML)";
        return shape && typeof shape.adj === "object";
      } catch (e) {
        return !1;
      }
    }(), mac = navigator.platform.indexOf("Mac") === 0, linux = navigator.platform.indexOf("Linux") === 0, Browser = {ie, ielt9, edge, webkit, android, android23, androidStock, opera, chrome, gecko, safari, phantom, opera12, win, ie3d, webkit3d, gecko3d, any3d, mobile, mobileWebkit, mobileWebkit3d, msPointer, pointer, touch, touchNative, mobileOpera, mobileGecko, retina, passiveEvents, canvas:canvas$1, svg:svg$1, vml, inlineSvg, mac, linux}, POINTER_DOWN = Browser.msPointer ? "MSPointerDown" : "pointerdown", 
    POINTER_MOVE = Browser.msPointer ? "MSPointerMove" : "pointermove", POINTER_UP = Browser.msPointer ? "MSPointerUp" : "pointerup", POINTER_CANCEL = Browser.msPointer ? "MSPointerCancel" : "pointercancel", pEvent = {touchstart:POINTER_DOWN, touchmove:POINTER_MOVE, touchend:POINTER_UP, touchcancel:POINTER_CANCEL}, handle = {touchstart:function(handler, e) {
      e.MSPOINTER_TYPE_TOUCH && e.pointerType === e.MSPOINTER_TYPE_TOUCH && preventDefault(e);
      _handlePointer(handler, e);
    }, touchmove:_handlePointer, touchend:_handlePointer, touchcancel:_handlePointer}, _pointers = {}, _pointerDocListener = !1, TRANSFORM = testProp(["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]), TRANSITION = testProp(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]), TRANSITION_END = TRANSITION === "webkitTransition" || TRANSITION === "OTransition" ? TRANSITION + "End" : "transitionend", _userSelect;
    if ("onselectstart" in document) {
      var disableTextSelection = function() {
        on(window, "selectstart", preventDefault);
      };
      var enableTextSelection = function() {
        off(window, "selectstart", preventDefault);
      };
    } else {
      var userSelectProperty = testProp(["userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect"]);
      disableTextSelection = function() {
        if (userSelectProperty) {
          var style = document.documentElement.style;
          _userSelect = style[userSelectProperty];
          style[userSelectProperty] = "none";
        }
      };
      enableTextSelection = function() {
        userSelectProperty && (document.documentElement.style[userSelectProperty] = _userSelect, _userSelect = void 0);
      };
    }
    var _outlineElement, _outlineStyle, DomUtil = {__proto__:null, TRANSFORM, TRANSITION, TRANSITION_END, get, getStyle, create:create$1, remove, empty, toFront, toBack, hasClass, addClass, removeClass, setClass, getClass, setOpacity, testProp, setTransform, setPosition, getPosition, get disableTextSelection() {
      return disableTextSelection;
    }, get enableTextSelection() {
      return enableTextSelection;
    }, disableImageDrag, enableImageDrag, preventOutline, restoreOutline, getSizedParentNode, getScale}, eventsKey = "_leaflet_events", mouseSubst = {mouseenter:"mouseover", mouseleave:"mouseout", wheel:!("onwheel" in window) && "mousewheel"}, wheelPxFactor = Browser.linux && Browser.chrome ? window.devicePixelRatio : Browser.mac ? window.devicePixelRatio * 3 : window.devicePixelRatio > 0 ? 2 * window.devicePixelRatio : 1, DomEvent = {__proto__:null, on, off, stopPropagation, disableScrollPropagation, 
    disableClickPropagation, preventDefault, stop, getPropagationPath, getMousePosition, getWheelDelta, isExternalTarget, addListener:on, removeListener:off}, PosAnimation = Evented.extend({run:function(el, newPos, duration, easeLinearity) {
      this.stop();
      this._el = el;
      this._inProgress = !0;
      this._duration = duration || 0.25;
      this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);
      this._startPos = getPosition(el);
      this._offset = newPos.subtract(this._startPos);
      this._startTime = +new Date();
      this.fire("start");
      this._animate();
    }, stop:function() {
      this._inProgress && (this._step(!0), this._complete());
    }, _animate:function() {
      this._animId = requestAnimFrame(this._animate, this);
      this._step();
    }, _step:function(round) {
      var elapsed = +new Date() - this._startTime, duration = this._duration * 1000;
      elapsed < duration ? this._runFrame(this._easeOut(elapsed / duration), round) : (this._runFrame(1), this._complete());
    }, _runFrame:function(progress, round) {
      progress = this._startPos.add(this._offset.multiplyBy(progress));
      round && progress._round();
      setPosition(this._el, progress);
      this.fire("step");
    }, _complete:function() {
      cancelAnimFrame(this._animId);
      this._inProgress = !1;
      this.fire("end");
    }, _easeOut:function(t) {
      return 1 - Math.pow(1 - t, this._easeOutPower);
    }}), Map = Evented.extend({options:{crs:EPSG3857, center:void 0, zoom:void 0, minZoom:void 0, maxZoom:void 0, layers:[], maxBounds:void 0, renderer:void 0, zoomAnimation:!0, zoomAnimationThreshold:4, fadeAnimation:!0, markerZoomAnimation:!0, transform3DLimit:8388608, zoomSnap:1, zoomDelta:1, trackResize:!0}, initialize:function(id, options) {
      options = setOptions(this, options);
      this._handlers = [];
      this._layers = {};
      this._zoomBoundLayers = {};
      this._sizeChanged = !0;
      this._initContainer(id);
      this._initLayout();
      this._onResize = bind(this._onResize, this);
      this._initEvents();
      options.maxBounds && this.setMaxBounds(options.maxBounds);
      options.zoom !== void 0 && (this._zoom = this._limitZoom(options.zoom));
      options.center && options.zoom !== void 0 && this.setView(toLatLng(options.center), options.zoom, {reset:!0});
      this.callInitHooks();
      if (this._zoomAnimated = TRANSITION && Browser.any3d && !Browser.mobileOpera && this.options.zoomAnimation) {
        this._createAnimProxy(), on(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);
      }
      this._addLayers(this.options.layers);
    }, setView:function(center, zoom, options) {
      zoom = zoom === void 0 ? this._zoom : this._limitZoom(zoom);
      center = this._limitCenter(toLatLng(center), zoom, this.options.maxBounds);
      options = options || {};
      this._stop();
      if (this._loaded && !options.reset && options !== !0 && (options.animate !== void 0 && (options.zoom = extend({animate:options.animate}, options.zoom), options.pan = extend({animate:options.animate, duration:options.duration}, options.pan)), this._zoom !== zoom ? this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) : this._tryAnimatedPan(center, options.pan))) {
        return clearTimeout(this._sizeTimer), this;
      }
      this._resetView(center, zoom, options.pan && options.pan.noMoveStart);
      return this;
    }, setZoom:function(zoom, options) {
      return this._loaded ? this.setView(this.getCenter(), zoom, {zoom:options}) : (this._zoom = zoom, this);
    }, zoomIn:function(delta, options) {
      delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);
      return this.setZoom(this._zoom + delta, options);
    }, zoomOut:function(delta, options) {
      delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);
      return this.setZoom(this._zoom - delta, options);
    }, setZoomAround:function(latlng, zoom, options) {
      var scale = this.getZoomScale(zoom), viewHalf = this.getSize().divideBy(2);
      latlng = (latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng)).subtract(viewHalf).multiplyBy(1 - 1 / scale);
      viewHalf = this.containerPointToLatLng(viewHalf.add(latlng));
      return this.setView(viewHalf, zoom, {zoom:options});
    }, _getBoundsCenterZoom:function(bounds, options) {
      options = options || {};
      bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);
      var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]), paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]), zoom = this.getBoundsZoom(bounds, !1, paddingTL.add(paddingBR));
      zoom = typeof options.maxZoom === "number" ? Math.min(options.maxZoom, zoom) : zoom;
      if (zoom === Infinity) {
        return {center:bounds.getCenter(), zoom};
      }
      options = paddingBR.subtract(paddingTL).divideBy(2);
      paddingTL = this.project(bounds.getSouthWest(), zoom);
      bounds = this.project(bounds.getNorthEast(), zoom);
      return {center:this.unproject(paddingTL.add(bounds).divideBy(2).add(options), zoom), zoom};
    }, fitBounds:function(bounds, options) {
      bounds = toLatLngBounds(bounds);
      if (!bounds.isValid()) {
        throw Error("Bounds are not valid.");
      }
      bounds = this._getBoundsCenterZoom(bounds, options);
      return this.setView(bounds.center, bounds.zoom, options);
    }, fitWorld:function(options) {
      return this.fitBounds([[-90, -180], [90, 180]], options);
    }, panTo:function(center, options) {
      return this.setView(center, this._zoom, {pan:options});
    }, panBy:function(offset, options) {
      offset = toPoint(offset).round();
      options = options || {};
      if (!offset.x && !offset.y) {
        return this.fire("moveend");
      }
      if (options.animate !== !0 && !this.getSize().contains(offset)) {
        return this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom()), this;
      }
      this._panAnim || (this._panAnim = new PosAnimation(), this._panAnim.on({step:this._onPanTransitionStep, end:this._onPanTransitionEnd}, this));
      options.noMoveStart || this.fire("movestart");
      options.animate !== !1 ? (addClass(this._mapPane, "leaflet-pan-anim"), offset = this._getMapPanePos().subtract(offset).round(), this._panAnim.run(this._mapPane, offset, options.duration || 0.25, options.easeLinearity)) : (this._rawPanBy(offset), this.fire("move").fire("moveend"));
      return this;
    }, flyTo:function(targetCenter, targetZoom, options) {
      function r(i) {
        i = (w1 * w1 - w0 * w0 + (i ? -1 : 1) * 2.0164 * 2.0164 * u1 * u1) / (2 * (i ? w1 : w0) * 2.0164 * u1);
        i = Math.sqrt(i * i + 1) - i;
        return i < 0.000000001 ? -18 : Math.log(i);
      }
      function cosh(n) {
        return (Math.exp(n) + Math.exp(-n)) / 2;
      }
      function frame() {
        var t = (Date.now() - start) / duration, s = (1 - Math.pow(1 - t, 1.5)) * S;
        if (t <= 1) {
          this._flyToFrame = requestAnimFrame(frame, this);
          t = this._move;
          var JSCompiler_temp_const = this.unproject, JSCompiler_temp_const$jscomp$0 = from, JSCompiler_temp_const$jscomp$1 = JSCompiler_temp_const$jscomp$0.add, JSCompiler_temp_const$jscomp$2 = to.subtract(from), JSCompiler_temp_const$jscomp$3 = JSCompiler_temp_const$jscomp$2.multiplyBy, JSCompiler_temp_const$jscomp$4 = cosh(r0);
          var JSCompiler_inline_result = r0 + 1.42 * s;
          JSCompiler_inline_result = (Math.exp(JSCompiler_inline_result) - Math.exp(-JSCompiler_inline_result)) / 2 / cosh(JSCompiler_inline_result);
          JSCompiler_temp_const = JSCompiler_temp_const.call(this, JSCompiler_temp_const$jscomp$1.call(JSCompiler_temp_const$jscomp$0, JSCompiler_temp_const$jscomp$3.call(JSCompiler_temp_const$jscomp$2, w0 * (JSCompiler_temp_const$jscomp$4 * JSCompiler_inline_result - (Math.exp(r0) - Math.exp(-r0)) / 2) / 2.0164 / u1)), startZoom);
          JSCompiler_temp_const$jscomp$0 = this.getScaleZoom;
          s = w0 * (cosh(r0) / cosh(r0 + 1.42 * s));
          t.call(this, JSCompiler_temp_const, JSCompiler_temp_const$jscomp$0.call(this, w0 / s, startZoom), {flyTo:!0});
        } else {
          this._move(targetCenter, targetZoom)._moveEnd(!0);
        }
      }
      options = options || {};
      if (options.animate === !1 || !Browser.any3d) {
        return this.setView(targetCenter, targetZoom, options);
      }
      this._stop();
      var from = this.project(this.getCenter()), to = this.project(targetCenter), size = this.getSize(), startZoom = this._zoom;
      targetCenter = toLatLng(targetCenter);
      targetZoom = targetZoom === void 0 ? startZoom : targetZoom;
      var w0 = Math.max(size.x, size.y), w1 = w0 * this.getZoomScale(startZoom, targetZoom), u1 = to.distanceTo(from) || 1, r0 = r(0), start = Date.now(), S = (r(1) - r0) / 1.42, duration = options.duration ? 1000 * options.duration : 1000 * S * 0.8;
      this._moveStart(!0, options.noMoveStart);
      frame.call(this);
      return this;
    }, flyToBounds:function(bounds, options) {
      bounds = this._getBoundsCenterZoom(bounds, options);
      return this.flyTo(bounds.center, bounds.zoom, options);
    }, setMaxBounds:function(bounds) {
      bounds = toLatLngBounds(bounds);
      this.listens("moveend", this._panInsideMaxBounds) && this.off("moveend", this._panInsideMaxBounds);
      if (!bounds.isValid()) {
        return this.options.maxBounds = null, this;
      }
      this.options.maxBounds = bounds;
      this._loaded && this._panInsideMaxBounds();
      return this.on("moveend", this._panInsideMaxBounds);
    }, setMinZoom:function(zoom) {
      var oldZoom = this.options.minZoom;
      this.options.minZoom = zoom;
      return this._loaded && oldZoom !== zoom && (this.fire("zoomlevelschange"), this.getZoom() < this.options.minZoom) ? this.setZoom(zoom) : this;
    }, setMaxZoom:function(zoom) {
      var oldZoom = this.options.maxZoom;
      this.options.maxZoom = zoom;
      return this._loaded && oldZoom !== zoom && (this.fire("zoomlevelschange"), this.getZoom() > this.options.maxZoom) ? this.setZoom(zoom) : this;
    }, panInsideBounds:function(bounds, options) {
      this._enforcingBounds = !0;
      var center = this.getCenter();
      bounds = this._limitCenter(center, this._zoom, toLatLngBounds(bounds));
      center.equals(bounds) || this.panTo(bounds, options);
      this._enforcingBounds = !1;
      return this;
    }, panInside:function(latlng, options) {
      options = options || {};
      var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]), paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]), pixelCenter = this.project(this.getCenter());
      latlng = this.project(latlng);
      var pixelBounds = this.getPixelBounds();
      paddingBR = toBounds([pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR)]);
      pixelBounds = paddingBR.getSize();
      paddingBR.contains(latlng) || (this._enforcingBounds = !0, paddingTL = latlng.subtract(paddingBR.getCenter()), latlng = paddingBR.extend(latlng).getSize().subtract(pixelBounds), pixelCenter.x += paddingTL.x < 0 ? -latlng.x : latlng.x, pixelCenter.y += paddingTL.y < 0 ? -latlng.y : latlng.y, this.panTo(this.unproject(pixelCenter), options), this._enforcingBounds = !1);
      return this;
    }, invalidateSize:function(options) {
      if (!this._loaded) {
        return this;
      }
      options = extend({animate:!1, pan:!0}, options === !0 ? {animate:!0} : options);
      var oldSize = this.getSize();
      this._sizeChanged = !0;
      this._lastCenter = null;
      var newSize = this.getSize(), oldCenter = oldSize.divideBy(2).round(), newCenter = newSize.divideBy(2).round();
      oldCenter = oldCenter.subtract(newCenter);
      if (!oldCenter.x && !oldCenter.y) {
        return this;
      }
      options.animate && options.pan ? this.panBy(oldCenter) : (options.pan && this._rawPanBy(oldCenter), this.fire("move"), options.debounceMoveend ? (clearTimeout(this._sizeTimer), this._sizeTimer = setTimeout(bind(this.fire, this, "moveend"), 200)) : this.fire("moveend"));
      return this.fire("resize", {oldSize, newSize});
    }, stop:function() {
      this.setZoom(this._limitZoom(this._zoom));
      this.options.zoomSnap || this.fire("viewreset");
      return this._stop();
    }, locate:function(options) {
      options = this._locateOptions = extend({timeout:10000, watch:!1}, options);
      if (!("geolocation" in navigator)) {
        return this._handleGeolocationError({code:0, message:"Geolocation not supported."}), this;
      }
      var onResponse = bind(this._handleGeolocationResponse, this), onError = bind(this._handleGeolocationError, this);
      options.watch ? this._locationWatchId = navigator.geolocation.watchPosition(onResponse, onError, options) : navigator.geolocation.getCurrentPosition(onResponse, onError, options);
      return this;
    }, stopLocate:function() {
      navigator.geolocation && navigator.geolocation.clearWatch && navigator.geolocation.clearWatch(this._locationWatchId);
      this._locateOptions && (this._locateOptions.setView = !1);
      return this;
    }, _handleGeolocationError:function(error) {
      if (this._container._leaflet_id) {
        var c = error.code;
        error = error.message || (c === 1 ? "permission denied" : c === 2 ? "position unavailable" : "timeout");
        this._locateOptions.setView && !this._loaded && this.fitWorld();
        this.fire("locationerror", {code:c, message:"Geolocation error: " + error + "."});
      }
    }, _handleGeolocationResponse:function(pos) {
      if (this._container._leaflet_id) {
        var latlng = new LatLng(pos.coords.latitude, pos.coords.longitude), bounds = latlng.toBounds(pos.coords.accuracy * 2), options = this._locateOptions;
        if (options.setView) {
          var zoom = this.getBoundsZoom(bounds);
          this.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);
        }
        latlng = {latlng, bounds, timestamp:pos.timestamp};
        for (var i in pos.coords) {
          typeof pos.coords[i] === "number" && (latlng[i] = pos.coords[i]);
        }
        this.fire("locationfound", latlng);
      }
    }, addHandler:function(name, HandlerClass) {
      if (!HandlerClass) {
        return this;
      }
      HandlerClass = this[name] = new HandlerClass(this);
      this._handlers.push(HandlerClass);
      this.options[name] && HandlerClass.enable();
      return this;
    }, remove:function() {
      this._initEvents(!0);
      this.options.maxBounds && this.off("moveend", this._panInsideMaxBounds);
      if (this._containerId !== this._container._leaflet_id) {
        throw Error("Map container is being reused by another instance");
      }
      try {
        delete this._container._leaflet_id, delete this._containerId;
      } catch (e) {
        this._containerId = this._container._leaflet_id = void 0;
      }
      this._locationWatchId !== void 0 && this.stopLocate();
      this._stop();
      remove(this._mapPane);
      this._clearControlPos && this._clearControlPos();
      this._resizeRequest && (cancelAnimFrame(this._resizeRequest), this._resizeRequest = null);
      this._clearHandlers();
      this._loaded && this.fire("unload");
      for (var i in this._layers) {
        this._layers[i].remove();
      }
      for (i in this._panes) {
        remove(this._panes[i]);
      }
      this._layers = [];
      this._panes = [];
      delete this._mapPane;
      delete this._renderer;
      return this;
    }, createPane:function(name, container) {
      var className = "leaflet-pane" + (name ? " leaflet-" + name.replace("Pane", "") + "-pane" : "");
      container = create$1("div", className, container || this._mapPane);
      name && (this._panes[name] = container);
      return container;
    }, getCenter:function() {
      this._checkIfLoaded();
      return this._lastCenter && !this._moved() ? this._lastCenter.clone() : this.layerPointToLatLng(this._getCenterLayerPoint());
    }, getZoom:function() {
      return this._zoom;
    }, getBounds:function() {
      var bounds = this.getPixelBounds(), sw = this.unproject(bounds.getBottomLeft());
      bounds = this.unproject(bounds.getTopRight());
      return new LatLngBounds(sw, bounds);
    }, getMinZoom:function() {
      return this.options.minZoom === void 0 ? this._layersMinZoom || 0 : this.options.minZoom;
    }, getMaxZoom:function() {
      return this.options.maxZoom === void 0 ? this._layersMaxZoom === void 0 ? Infinity : this._layersMaxZoom : this.options.maxZoom;
    }, getBoundsZoom:function(bounds, inside, padding) {
      bounds = toLatLngBounds(bounds);
      padding = toPoint(padding || [0, 0]);
      var zoom = this.getZoom() || 0, min = this.getMinZoom(), max = this.getMaxZoom(), nw = bounds.getNorthWest();
      bounds = bounds.getSouthEast();
      padding = this.getSize().subtract(padding);
      var boundsSize = toBounds(this.project(bounds, zoom), this.project(nw, zoom)).getSize();
      nw = Browser.any3d ? this.options.zoomSnap : 1;
      bounds = padding.x / boundsSize.x;
      padding = padding.y / boundsSize.y;
      zoom = this.getScaleZoom(inside ? Math.max(bounds, padding) : Math.min(bounds, padding), zoom);
      nw && (zoom = nw / 100 * Math.round(zoom / (nw / 100)), zoom = inside ? Math.ceil(zoom / nw) * nw : Math.floor(zoom / nw) * nw);
      return Math.max(min, Math.min(max, zoom));
    }, getSize:function() {
      if (!this._size || this._sizeChanged) {
        this._size = new Point(this._container.clientWidth || 0, this._container.clientHeight || 0), this._sizeChanged = !1;
      }
      return this._size.clone();
    }, getPixelBounds:function(center, zoom) {
      center = this._getTopLeftPoint(center, zoom);
      return new Bounds(center, center.add(this.getSize()));
    }, getPixelOrigin:function() {
      this._checkIfLoaded();
      return this._pixelOrigin;
    }, getPixelWorldBounds:function(zoom) {
      return this.options.crs.getProjectedBounds(zoom === void 0 ? this.getZoom() : zoom);
    }, getPane:function(pane) {
      return typeof pane === "string" ? this._panes[pane] : pane;
    }, getPanes:function() {
      return this._panes;
    }, getContainer:function() {
      return this._container;
    }, getZoomScale:function(toZoom, fromZoom) {
      var crs = this.options.crs;
      fromZoom = fromZoom === void 0 ? this._zoom : fromZoom;
      return crs.scale(toZoom) / crs.scale(fromZoom);
    }, getScaleZoom:function(scale, fromZoom) {
      var crs = this.options.crs;
      fromZoom = fromZoom === void 0 ? this._zoom : fromZoom;
      scale = crs.zoom(scale * crs.scale(fromZoom));
      return isNaN(scale) ? Infinity : scale;
    }, project:function(latlng, zoom) {
      zoom = zoom === void 0 ? this._zoom : zoom;
      return this.options.crs.latLngToPoint(toLatLng(latlng), zoom);
    }, unproject:function(point, zoom) {
      zoom = zoom === void 0 ? this._zoom : zoom;
      return this.options.crs.pointToLatLng(toPoint(point), zoom);
    }, layerPointToLatLng:function(point) {
      point = toPoint(point).add(this.getPixelOrigin());
      return this.unproject(point);
    }, latLngToLayerPoint:function(latlng) {
      return this.project(toLatLng(latlng))._round()._subtract(this.getPixelOrigin());
    }, wrapLatLng:function(latlng) {
      return this.options.crs.wrapLatLng(toLatLng(latlng));
    }, wrapLatLngBounds:function(latlng) {
      return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));
    }, distance:function(latlng1, latlng2) {
      return this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));
    }, containerPointToLayerPoint:function(point) {
      return toPoint(point).subtract(this._getMapPanePos());
    }, layerPointToContainerPoint:function(point) {
      return toPoint(point).add(this._getMapPanePos());
    }, containerPointToLatLng:function(point) {
      point = this.containerPointToLayerPoint(toPoint(point));
      return this.layerPointToLatLng(point);
    }, latLngToContainerPoint:function(latlng) {
      return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));
    }, mouseEventToContainerPoint:function(e) {
      return getMousePosition(e, this._container);
    }, mouseEventToLayerPoint:function(e) {
      return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
    }, mouseEventToLatLng:function(e) {
      return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
    }, _initContainer:function(id) {
      id = this._container = get(id);
      if (!id) {
        throw Error("Map container not found.");
      }
      if (id._leaflet_id) {
        throw Error("Map container is already initialized.");
      }
      on(id, "scroll", this._onScroll, this);
      this._containerId = stamp(id);
    }, _initLayout:function() {
      var container = this._container;
      this._fadeAnimated = this.options.fadeAnimation && Browser.any3d;
      addClass(container, "leaflet-container" + (Browser.touch ? " leaflet-touch" : "") + (Browser.retina ? " leaflet-retina" : "") + (Browser.ielt9 ? " leaflet-oldie" : "") + (Browser.safari ? " leaflet-safari" : "") + (this._fadeAnimated ? " leaflet-fade-anim" : ""));
      var position = getStyle(container, "position");
      position !== "absolute" && position !== "relative" && position !== "fixed" && position !== "sticky" && (container.style.position = "relative");
      this._initPanes();
      this._initControlPos && this._initControlPos();
    }, _initPanes:function() {
      var panes = this._panes = {};
      this._paneRenderers = {};
      this._mapPane = this.createPane("mapPane", this._container);
      setPosition(this._mapPane, new Point(0, 0));
      this.createPane("tilePane");
      this.createPane("overlayPane");
      this.createPane("shadowPane");
      this.createPane("markerPane");
      this.createPane("tooltipPane");
      this.createPane("popupPane");
      this.options.markerZoomAnimation || (addClass(panes.markerPane, "leaflet-zoom-hide"), addClass(panes.shadowPane, "leaflet-zoom-hide"));
    }, _resetView:function(center, zoom, noMoveStart) {
      setPosition(this._mapPane, new Point(0, 0));
      var loading = !this._loaded;
      this._loaded = !0;
      zoom = this._limitZoom(zoom);
      this.fire("viewprereset");
      var zoomChanged = this._zoom !== zoom;
      this._moveStart(zoomChanged, noMoveStart)._move(center, zoom)._moveEnd(zoomChanged);
      this.fire("viewreset");
      loading && this.fire("load");
    }, _moveStart:function(zoomChanged, noMoveStart) {
      zoomChanged && this.fire("zoomstart");
      noMoveStart || this.fire("movestart");
      return this;
    }, _move:function(center, zoom, data, supressEvent) {
      zoom === void 0 && (zoom = this._zoom);
      var zoomChanged = this._zoom !== zoom;
      this._zoom = zoom;
      this._lastCenter = center;
      this._pixelOrigin = this._getNewPixelOrigin(center);
      supressEvent ? data && data.pinch && this.fire("zoom", data) : ((zoomChanged || data && data.pinch) && this.fire("zoom", data), this.fire("move", data));
      return this;
    }, _moveEnd:function(zoomChanged) {
      zoomChanged && this.fire("zoomend");
      return this.fire("moveend");
    }, _stop:function() {
      cancelAnimFrame(this._flyToFrame);
      this._panAnim && this._panAnim.stop();
      return this;
    }, _rawPanBy:function(offset) {
      setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
    }, _getZoomSpan:function() {
      return this.getMaxZoom() - this.getMinZoom();
    }, _panInsideMaxBounds:function() {
      this._enforcingBounds || this.panInsideBounds(this.options.maxBounds);
    }, _checkIfLoaded:function() {
      if (!this._loaded) {
        throw Error("Set map center and zoom first.");
      }
    }, _initEvents:function(remove) {
      this._targets = {};
      this._targets[stamp(this._container)] = this;
      var onOff = remove ? off : on;
      onOff(this._container, "click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu keypress keydown keyup", this._handleDOMEvent, this);
      this.options.trackResize && onOff(window, "resize", this._onResize, this);
      Browser.any3d && this.options.transform3DLimit && (remove ? this.off : this.on).call(this, "moveend", this._onMoveEnd);
    }, _onResize:function() {
      cancelAnimFrame(this._resizeRequest);
      this._resizeRequest = requestAnimFrame(function() {
        this.invalidateSize({debounceMoveend:!0});
      }, this);
    }, _onScroll:function() {
      this._container.scrollTop = 0;
      this._container.scrollLeft = 0;
    }, _onMoveEnd:function() {
      var pos = this._getMapPanePos();
      Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit && this._resetView(this.getCenter(), this.getZoom());
    }, _findEventTargets:function(e, type) {
      for (var targets = [], target, isHover = type === "mouseout" || type === "mouseover", src = e.target || e.srcElement, dragging = !1; src;) {
        if ((target = this._targets[stamp(src)]) && (type === "click" || type === "preclick") && this._draggableMoved(target)) {
          dragging = !0;
          break;
        }
        if (target && target.listens(type, !0)) {
          if (isHover && !isExternalTarget(src, e)) {
            break;
          }
          targets.push(target);
          if (isHover) {
            break;
          }
        }
        if (src === this._container) {
          break;
        }
        src = src.parentNode;
      }
      targets.length || dragging || isHover || !this.listens(type, !0) || (targets = [this]);
      return targets;
    }, _isClickDisabled:function(el) {
      for (; el && el !== this._container;) {
        if (el._leaflet_disable_click) {
          return !0;
        }
        el = el.parentNode;
      }
    }, _handleDOMEvent:function(e) {
      var el = e.target || e.srcElement;
      if (!(!this._loaded || el._leaflet_disable_events || e.type === "click" && this._isClickDisabled(el))) {
        var type = e.type;
        type === "mousedown" && preventOutline(el);
        this._fireDOMEvent(e, type);
      }
    }, _mouseEvents:["click", "dblclick", "mouseover", "mouseout", "contextmenu"], _fireDOMEvent:function(e, type, canvasTargets) {
      if (e.type === "click") {
        var synth = extend({}, e);
        synth.type = "preclick";
        this._fireDOMEvent(synth, synth.type, canvasTargets);
      }
      synth = this._findEventTargets(e, type);
      if (canvasTargets) {
        for (var filtered = [], i = 0; i < canvasTargets.length; i++) {
          canvasTargets[i].listens(type, !0) && filtered.push(canvasTargets[i]);
        }
        synth = filtered.concat(synth);
      }
      if (synth.length) {
        for (type === "contextmenu" && preventDefault(e), i = synth[0], canvasTargets = {originalEvent:e}, e.type !== "keypress" && e.type !== "keydown" && e.type !== "keyup" && (filtered = i.getLatLng && (!i._radius || i._radius <= 10), canvasTargets.containerPoint = filtered ? this.latLngToContainerPoint(i.getLatLng()) : this.mouseEventToContainerPoint(e), canvasTargets.layerPoint = this.containerPointToLayerPoint(canvasTargets.containerPoint), canvasTargets.latlng = filtered ? i.getLatLng() : 
        this.layerPointToLatLng(canvasTargets.layerPoint)), i = 0; i < synth.length && !(synth[i].fire(type, canvasTargets, !0), canvasTargets.originalEvent._stopped || synth[i].options.bubblingMouseEvents === !1 && indexOf(this._mouseEvents, type) !== -1); i++) {
        }
      }
    }, _draggableMoved:function(obj) {
      obj = obj.dragging && obj.dragging.enabled() ? obj : this;
      return obj.dragging && obj.dragging.moved() || this.boxZoom && this.boxZoom.moved();
    }, _clearHandlers:function() {
      for (var i = 0, len = this._handlers.length; i < len; i++) {
        this._handlers[i].disable();
      }
    }, whenReady:function(callback, context) {
      if (this._loaded) {
        callback.call(context || this, {target:this});
      } else {
        this.on("load", callback, context);
      }
      return this;
    }, _getMapPanePos:function() {
      return getPosition(this._mapPane) || new Point(0, 0);
    }, _moved:function() {
      var pos = this._getMapPanePos();
      return pos && !pos.equals([0, 0]);
    }, _getTopLeftPoint:function(center, zoom) {
      return (center && zoom !== void 0 ? this._getNewPixelOrigin(center, zoom) : this.getPixelOrigin()).subtract(this._getMapPanePos());
    }, _getNewPixelOrigin:function(center, zoom) {
      var viewHalf = this.getSize()._divideBy(2);
      return this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round();
    }, _latLngToNewLayerPoint:function(latlng, zoom, center) {
      center = this._getNewPixelOrigin(center, zoom);
      return this.project(latlng, zoom)._subtract(center);
    }, _latLngBoundsToNewLayerBounds:function(latLngBounds, zoom, center) {
      center = this._getNewPixelOrigin(center, zoom);
      return toBounds([this.project(latLngBounds.getSouthWest(), zoom)._subtract(center), this.project(latLngBounds.getNorthWest(), zoom)._subtract(center), this.project(latLngBounds.getSouthEast(), zoom)._subtract(center), this.project(latLngBounds.getNorthEast(), zoom)._subtract(center)]);
    }, _getCenterLayerPoint:function() {
      return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
    }, _getCenterOffset:function(latlng) {
      return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
    }, _limitCenter:function(center, zoom, bounds) {
      if (!bounds) {
        return center;
      }
      var centerPoint = this.project(center, zoom), viewHalf = this.getSize().divideBy(2);
      viewHalf = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf));
      bounds = this._getBoundsOffset(viewHalf, bounds, zoom);
      return Math.abs(bounds.x) <= 1 && Math.abs(bounds.y) <= 1 ? center : this.unproject(centerPoint.add(bounds), zoom);
    }, _limitOffset:function(offset, bounds) {
      if (!bounds) {
        return offset;
      }
      var viewBounds = this.getPixelBounds();
      viewBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));
      return offset.add(this._getBoundsOffset(viewBounds, bounds));
    }, _getBoundsOffset:function(pxBounds, maxBounds, zoom) {
      zoom = toBounds(this.project(maxBounds.getNorthEast(), zoom), this.project(maxBounds.getSouthWest(), zoom));
      maxBounds = zoom.min.subtract(pxBounds.min);
      zoom = zoom.max.subtract(pxBounds.max);
      pxBounds = this._rebound(maxBounds.x, -zoom.x);
      maxBounds = this._rebound(maxBounds.y, -zoom.y);
      return new Point(pxBounds, maxBounds);
    }, _rebound:function(left, right) {
      return left + right > 0 ? Math.round(left - right) / 2 : Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
    }, _limitZoom:function(zoom) {
      var min = this.getMinZoom(), max = this.getMaxZoom(), snap = Browser.any3d ? this.options.zoomSnap : 1;
      snap && (zoom = Math.round(zoom / snap) * snap);
      return Math.max(min, Math.min(max, zoom));
    }, _onPanTransitionStep:function() {
      this.fire("move");
    }, _onPanTransitionEnd:function() {
      removeClass(this._mapPane, "leaflet-pan-anim");
      this.fire("moveend");
    }, _tryAnimatedPan:function(center, options) {
      center = this._getCenterOffset(center)._trunc();
      if ((options && options.animate) !== !0 && !this.getSize().contains(center)) {
        return !1;
      }
      this.panBy(center, options);
      return !0;
    }, _createAnimProxy:function() {
      var proxy = this._proxy = create$1("div", "leaflet-proxy leaflet-zoom-animated");
      this._panes.mapPane.appendChild(proxy);
      this.on("zoomanim", function(e) {
        var prop = TRANSFORM, transform = this._proxy.style[prop];
        setTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));
        transform === this._proxy.style[prop] && this._animatingZoom && this._onZoomTransitionEnd();
      }, this);
      this.on("load moveend", this._animMoveEnd, this);
      this._on("unload", this._destroyAnimProxy, this);
    }, _destroyAnimProxy:function() {
      remove(this._proxy);
      this.off("load moveend", this._animMoveEnd, this);
      delete this._proxy;
    }, _animMoveEnd:function() {
      var c = this.getCenter(), z = this.getZoom();
      setTransform(this._proxy, this.project(c, z), this.getZoomScale(z, 1));
    }, _catchTransitionEnd:function(e) {
      this._animatingZoom && e.propertyName.indexOf("transform") >= 0 && this._onZoomTransitionEnd();
    }, _nothingToAnimate:function() {
      return !this._container.getElementsByClassName("leaflet-zoom-animated").length;
    }, _tryAnimatedZoom:function(center, zoom, options) {
      if (this._animatingZoom) {
        return !0;
      }
      options = options || {};
      if (!this._zoomAnimated || options.animate === !1 || this._nothingToAnimate() || Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) {
        return !1;
      }
      var scale = this.getZoomScale(zoom);
      scale = this._getCenterOffset(center)._divideBy(1 - 1 / scale);
      if (options.animate !== !0 && !this.getSize().contains(scale)) {
        return !1;
      }
      requestAnimFrame(function() {
        this._moveStart(!0, options.noMoveStart || !1)._animateZoom(center, zoom, !0);
      }, this);
      return !0;
    }, _animateZoom:function(center, zoom, startAnim, noUpdate) {
      this._mapPane && (startAnim && (this._animatingZoom = !0, this._animateToCenter = center, this._animateToZoom = zoom, addClass(this._mapPane, "leaflet-zoom-anim")), this.fire("zoomanim", {center, zoom, noUpdate}), this._tempFireZoomEvent || (this._tempFireZoomEvent = this._zoom !== this._animateToZoom), this._move(this._animateToCenter, this._animateToZoom, void 0, !0), setTimeout(bind(this._onZoomTransitionEnd, this), 250));
    }, _onZoomTransitionEnd:function() {
      this._animatingZoom && (this._mapPane && removeClass(this._mapPane, "leaflet-zoom-anim"), this._animatingZoom = !1, this._move(this._animateToCenter, this._animateToZoom, void 0, !0), this._tempFireZoomEvent && this.fire("zoom"), delete this._tempFireZoomEvent, this.fire("move"), this._moveEnd(!0));
    }}), Control = Class.extend({options:{position:"topright"}, initialize:function(options) {
      setOptions(this, options);
    }, getPosition:function() {
      return this.options.position;
    }, setPosition:function(position) {
      var map = this._map;
      map && map.removeControl(this);
      this.options.position = position;
      map && map.addControl(this);
      return this;
    }, getContainer:function() {
      return this._container;
    }, addTo:function(map) {
      this.remove();
      this._map = map;
      var container = this._container = this.onAdd(map), pos = this.getPosition();
      map = map._controlCorners[pos];
      addClass(container, "leaflet-control");
      pos.indexOf("bottom") !== -1 ? map.insertBefore(container, map.firstChild) : map.appendChild(container);
      this._map.on("unload", this.remove, this);
      return this;
    }, remove:function() {
      if (!this._map) {
        return this;
      }
      remove(this._container);
      if (this.onRemove) {
        this.onRemove(this._map);
      }
      this._map.off("unload", this.remove, this);
      this._map = null;
      return this;
    }, _refocusOnMap:function(e) {
      this._map && e && e.screenX > 0 && e.screenY > 0 && this._map.getContainer().focus();
    }}), control = function(options) {
      return new Control(options);
    };
    Map.include({addControl:function(control) {
      control.addTo(this);
      return this;
    }, removeControl:function(control) {
      control.remove();
      return this;
    }, _initControlPos:function() {
      function createCorner(vSide, hSide) {
        corners[vSide + hSide] = create$1("div", "leaflet-" + vSide + " leaflet-" + hSide, container);
      }
      var corners = this._controlCorners = {}, container = this._controlContainer = create$1("div", "leaflet-control-container", this._container);
      createCorner("top", "left");
      createCorner("top", "right");
      createCorner("bottom", "left");
      createCorner("bottom", "right");
    }, _clearControlPos:function() {
      for (var i in this._controlCorners) {
        remove(this._controlCorners[i]);
      }
      remove(this._controlContainer);
      delete this._controlCorners;
      delete this._controlContainer;
    }});
    var Layers = Control.extend({options:{collapsed:!0, position:"topright", autoZIndex:!0, hideSingleBase:!1, sortLayers:!1, sortFunction:function(layerA, layerB, nameA, nameB) {
      return nameA < nameB ? -1 : nameB < nameA ? 1 : 0;
    }}, initialize:function(baseLayers, overlays, options) {
      setOptions(this, options);
      this._layerControlInputs = [];
      this._layers = [];
      this._lastZIndex = 0;
      this._preventClick = this._handlingClick = !1;
      for (var i in baseLayers) {
        this._addLayer(baseLayers[i], i);
      }
      for (i in overlays) {
        this._addLayer(overlays[i], i, !0);
      }
    }, onAdd:function(map) {
      this._initLayout();
      this._update();
      this._map = map;
      map.on("zoomend", this._checkDisabledLayers, this);
      for (map = 0; map < this._layers.length; map++) {
        this._layers[map].layer.on("add remove", this._onLayerChange, this);
      }
      return this._container;
    }, addTo:function(map) {
      Control.prototype.addTo.call(this, map);
      return this._expandIfNotCollapsed();
    }, onRemove:function() {
      this._map.off("zoomend", this._checkDisabledLayers, this);
      for (var i = 0; i < this._layers.length; i++) {
        this._layers[i].layer.off("add remove", this._onLayerChange, this);
      }
    }, addBaseLayer:function(layer, name) {
      this._addLayer(layer, name);
      return this._map ? this._update() : this;
    }, addOverlay:function(layer, name) {
      this._addLayer(layer, name, !0);
      return this._map ? this._update() : this;
    }, removeLayer:function(layer) {
      layer.off("add remove", this._onLayerChange, this);
      (layer = this._getLayer(stamp(layer))) && this._layers.splice(this._layers.indexOf(layer), 1);
      return this._map ? this._update() : this;
    }, expand:function() {
      addClass(this._container, "leaflet-control-layers-expanded");
      this._section.style.height = null;
      var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);
      acceptableHeight < this._section.clientHeight ? (addClass(this._section, "leaflet-control-layers-scrollbar"), this._section.style.height = acceptableHeight + "px") : removeClass(this._section, "leaflet-control-layers-scrollbar");
      this._checkDisabledLayers();
      return this;
    }, collapse:function() {
      removeClass(this._container, "leaflet-control-layers-expanded");
      return this;
    }, _initLayout:function() {
      var container = this._container = create$1("div", "leaflet-control-layers"), collapsed = this.options.collapsed;
      container.setAttribute("aria-haspopup", !0);
      disableClickPropagation(container);
      disableScrollPropagation(container);
      var section = this._section = create$1("section", "leaflet-control-layers-list");
      collapsed && (this._map.on("click", this.collapse, this), on(container, {mouseenter:this._expandSafely, mouseleave:this.collapse}, this));
      var link = this._layersLink = create$1("a", "leaflet-control-layers-toggle", container);
      link.href = "#";
      link.title = "Layers";
      link.setAttribute("role", "button");
      on(link, {keydown:function(e) {
        e.keyCode === 13 && this._expandSafely();
      }, click:function(e) {
        preventDefault(e);
        this._expandSafely();
      }}, this);
      collapsed || this.expand();
      this._baseLayersList = create$1("div", "leaflet-control-layers-base", section);
      this._separator = create$1("div", "leaflet-control-layers-separator", section);
      this._overlaysList = create$1("div", "leaflet-control-layers-overlays", section);
      container.appendChild(section);
    }, _getLayer:function(id) {
      for (var i = 0; i < this._layers.length; i++) {
        if (this._layers[i] && stamp(this._layers[i].layer) === id) {
          return this._layers[i];
        }
      }
    }, _addLayer:function(layer, name, overlay) {
      if (this._map) {
        layer.on("add remove", this._onLayerChange, this);
      }
      this._layers.push({layer, name, overlay});
      this.options.sortLayers && this._layers.sort(bind(function(a, b) {
        return this.options.sortFunction(a.layer, b.layer, a.name, b.name);
      }, this));
      this.options.autoZIndex && layer.setZIndex && (this._lastZIndex++, layer.setZIndex(this._lastZIndex));
      this._expandIfNotCollapsed();
    }, _update:function() {
      if (!this._container) {
        return this;
      }
      empty(this._baseLayersList);
      empty(this._overlaysList);
      this._layerControlInputs = [];
      var i, baseLayersCount = 0;
      for (i = 0; i < this._layers.length; i++) {
        var obj = this._layers[i];
        this._addItem(obj);
        var overlaysPresent = overlaysPresent || obj.overlay;
        var baseLayersPresent = baseLayersPresent || !obj.overlay;
        baseLayersCount += obj.overlay ? 0 : 1;
      }
      this.options.hideSingleBase && (baseLayersPresent = baseLayersPresent && baseLayersCount > 1, this._baseLayersList.style.display = baseLayersPresent ? "" : "none");
      this._separator.style.display = overlaysPresent && baseLayersPresent ? "" : "none";
      return this;
    }, _onLayerChange:function(e) {
      this._handlingClick || this._update();
      var obj = this._getLayer(stamp(e.target));
      (e = obj.overlay ? e.type === "add" ? "overlayadd" : "overlayremove" : e.type === "add" ? "baselayerchange" : null) && this._map.fire(e, obj);
    }, _createRadioElement:function(name, checked) {
      name = '\x3cinput type\x3d"radio" class\x3d"leaflet-control-layers-selector" name\x3d"' + name + '"' + (checked ? ' checked\x3d"checked"' : "") + "/\x3e";
      checked = document.createElement("div");
      checked.innerHTML = name;
      return checked.firstChild;
    }, _addItem:function(obj) {
      var label = document.createElement("label"), checked = this._map.hasLayer(obj.layer);
      if (obj.overlay) {
        var input = document.createElement("input");
        input.type = "checkbox";
        input.className = "leaflet-control-layers-selector";
        input.defaultChecked = checked;
      } else {
        input = this._createRadioElement("leaflet-base-layers_" + stamp(this), checked);
      }
      this._layerControlInputs.push(input);
      input.layerId = stamp(obj.layer);
      on(input, "click", this._onInputClick, this);
      checked = document.createElement("span");
      checked.innerHTML = " " + obj.name;
      var holder = document.createElement("span");
      label.appendChild(holder);
      holder.appendChild(input);
      holder.appendChild(checked);
      (obj.overlay ? this._overlaysList : this._baseLayersList).appendChild(label);
      this._checkDisabledLayers();
      return label;
    }, _onInputClick:function() {
      if (!this._preventClick) {
        var inputs = this._layerControlInputs, addedLayers = [], removedLayers = [];
        this._handlingClick = !0;
        for (var i = inputs.length - 1; i >= 0; i--) {
          var input = inputs[i];
          var layer = this._getLayer(input.layerId).layer;
          input.checked ? addedLayers.push(layer) : input.checked || removedLayers.push(layer);
        }
        for (i = 0; i < removedLayers.length; i++) {
          this._map.hasLayer(removedLayers[i]) && this._map.removeLayer(removedLayers[i]);
        }
        for (i = 0; i < addedLayers.length; i++) {
          this._map.hasLayer(addedLayers[i]) || this._map.addLayer(addedLayers[i]);
        }
        this._handlingClick = !1;
        this._refocusOnMap();
      }
    }, _checkDisabledLayers:function() {
      for (var inputs = this._layerControlInputs, input, layer, zoom = this._map.getZoom(), i = inputs.length - 1; i >= 0; i--) {
        input = inputs[i], layer = this._getLayer(input.layerId).layer, input.disabled = layer.options.minZoom !== void 0 && zoom < layer.options.minZoom || layer.options.maxZoom !== void 0 && zoom > layer.options.maxZoom;
      }
    }, _expandIfNotCollapsed:function() {
      this._map && !this.options.collapsed && this.expand();
      return this;
    }, _expandSafely:function() {
      var section = this._section;
      this._preventClick = !0;
      on(section, "click", preventDefault);
      this.expand();
      var that = this;
      setTimeout(function() {
        off(section, "click", preventDefault);
        that._preventClick = !1;
      });
    }}), Zoom = Control.extend({options:{position:"topleft", zoomInText:'\x3cspan aria-hidden\x3d"true"\x3e+\x3c/span\x3e', zoomInTitle:"Zoom in", zoomOutText:'\x3cspan aria-hidden\x3d"true"\x3e\x26#x2212;\x3c/span\x3e', zoomOutTitle:"Zoom out"}, onAdd:function(map) {
      var container = create$1("div", "leaflet-control-zoom leaflet-bar"), options = this.options;
      this._zoomInButton = this._createButton(options.zoomInText, options.zoomInTitle, "leaflet-control-zoom-in", container, this._zoomIn);
      this._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle, "leaflet-control-zoom-out", container, this._zoomOut);
      this._updateDisabled();
      map.on("zoomend zoomlevelschange", this._updateDisabled, this);
      return container;
    }, onRemove:function(map) {
      map.off("zoomend zoomlevelschange", this._updateDisabled, this);
    }, disable:function() {
      this._disabled = !0;
      this._updateDisabled();
      return this;
    }, enable:function() {
      this._disabled = !1;
      this._updateDisabled();
      return this;
    }, _zoomIn:function(e) {
      !this._disabled && this._map._zoom < this._map.getMaxZoom() && this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
    }, _zoomOut:function(e) {
      !this._disabled && this._map._zoom > this._map.getMinZoom() && this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
    }, _createButton:function(html, title, className, container, fn) {
      className = create$1("a", className, container);
      className.innerHTML = html;
      className.href = "#";
      className.title = title;
      className.setAttribute("role", "button");
      className.setAttribute("aria-label", title);
      disableClickPropagation(className);
      on(className, "click", stop);
      on(className, "click", fn, this);
      on(className, "click", this._refocusOnMap, this);
      return className;
    }, _updateDisabled:function() {
      var map = this._map;
      removeClass(this._zoomInButton, "leaflet-disabled");
      removeClass(this._zoomOutButton, "leaflet-disabled");
      this._zoomInButton.setAttribute("aria-disabled", "false");
      this._zoomOutButton.setAttribute("aria-disabled", "false");
      if (this._disabled || map._zoom === map.getMinZoom()) {
        addClass(this._zoomOutButton, "leaflet-disabled"), this._zoomOutButton.setAttribute("aria-disabled", "true");
      }
      if (this._disabled || map._zoom === map.getMaxZoom()) {
        addClass(this._zoomInButton, "leaflet-disabled"), this._zoomInButton.setAttribute("aria-disabled", "true");
      }
    }});
    Map.mergeOptions({zoomControl:!0});
    Map.addInitHook(function() {
      this.options.zoomControl && (this.zoomControl = new Zoom(), this.addControl(this.zoomControl));
    });
    var Scale = Control.extend({options:{position:"bottomleft", maxWidth:100, metric:!0, imperial:!0}, onAdd:function(map) {
      var container = create$1("div", "leaflet-control-scale"), options = this.options;
      this._addScales(options, "leaflet-control-scale-line", container);
      map.on(options.updateWhenIdle ? "moveend" : "move", this._update, this);
      map.whenReady(this._update, this);
      return container;
    }, onRemove:function(map) {
      map.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this);
    }, _addScales:function(options, className, container) {
      options.metric && (this._mScale = create$1("div", className, container));
      options.imperial && (this._iScale = create$1("div", className, container));
    }, _update:function() {
      var map = this._map, y = map.getSize().y / 2;
      map = map.distance(map.containerPointToLatLng([0, y]), map.containerPointToLatLng([this.options.maxWidth, y]));
      this._updateScales(map);
    }, _updateScales:function(maxMeters) {
      this.options.metric && maxMeters && this._updateMetric(maxMeters);
      this.options.imperial && maxMeters && this._updateImperial(maxMeters);
    }, _updateMetric:function(maxMeters) {
      var meters = this._getRoundNum(maxMeters);
      this._updateScale(this._mScale, meters < 1000 ? meters + " m" : meters / 1000 + " km", meters / maxMeters);
    }, _updateImperial:function(maxMeters) {
      maxMeters *= 3.2808399;
      if (maxMeters > 5280) {
        maxMeters /= 5280;
        var miles = this._getRoundNum(maxMeters);
        this._updateScale(this._iScale, miles + " mi", miles / maxMeters);
      } else {
        miles = this._getRoundNum(maxMeters), this._updateScale(this._iScale, miles + " ft", miles / maxMeters);
      }
    }, _updateScale:function(scale, text, ratio) {
      scale.style.width = Math.round(this.options.maxWidth * ratio) + "px";
      scale.innerHTML = text;
    }, _getRoundNum:function(num) {
      var pow10 = Math.pow(10, (Math.floor(num) + "").length - 1);
      num /= pow10;
      return pow10 * (num >= 10 ? 10 : num >= 5 ? 5 : num >= 3 ? 3 : num >= 2 ? 2 : 1);
    }}), Attribution = Control.extend({options:{position:"bottomright", prefix:'\x3ca href\x3d"https://leafletjs.com" title\x3d"A JavaScript library for interactive maps"\x3e' + (Browser.inlineSvg ? '\x3csvg aria-hidden\x3d"true" xmlns\x3d"http://www.w3.org/2000/svg" width\x3d"12" height\x3d"8" viewBox\x3d"0 0 12 8" class\x3d"leaflet-attribution-flag"\x3e\x3cpath fill\x3d"#4C7BE1" d\x3d"M0 0h12v4H0z"/\x3e\x3cpath fill\x3d"#FFD500" d\x3d"M0 4h12v3H0z"/\x3e\x3cpath fill\x3d"#E0BC00" d\x3d"M0 7h12v1H0z"/\x3e\x3c/svg\x3e ' : 
    "") + "Leaflet\x3c/a\x3e"}, initialize:function(options) {
      setOptions(this, options);
      this._attributions = {};
    }, onAdd:function(map) {
      map.attributionControl = this;
      this._container = create$1("div", "leaflet-control-attribution");
      disableClickPropagation(this._container);
      for (var i in map._layers) {
        map._layers[i].getAttribution && this.addAttribution(map._layers[i].getAttribution());
      }
      this._update();
      map.on("layeradd", this._addAttribution, this);
      return this._container;
    }, onRemove:function(map) {
      map.off("layeradd", this._addAttribution, this);
    }, _addAttribution:function(ev) {
      ev.layer.getAttribution && (this.addAttribution(ev.layer.getAttribution()), ev.layer.once("remove", function() {
        this.removeAttribution(ev.layer.getAttribution());
      }, this));
    }, setPrefix:function(prefix) {
      this.options.prefix = prefix;
      this._update();
      return this;
    }, addAttribution:function(text) {
      if (!text) {
        return this;
      }
      this._attributions[text] || (this._attributions[text] = 0);
      this._attributions[text]++;
      this._update();
      return this;
    }, removeAttribution:function(text) {
      if (!text) {
        return this;
      }
      this._attributions[text] && (this._attributions[text]--, this._update());
      return this;
    }, _update:function() {
      if (this._map) {
        var attribs = [];
        for (i in this._attributions) {
          this._attributions[i] && attribs.push(i);
        }
        var i = [];
        this.options.prefix && i.push(this.options.prefix);
        attribs.length && i.push(attribs.join(", "));
        this._container.innerHTML = i.join(' \x3cspan aria-hidden\x3d"true"\x3e|\x3c/span\x3e ');
      }
    }});
    Map.mergeOptions({attributionControl:!0});
    Map.addInitHook(function() {
      this.options.attributionControl && (new Attribution()).addTo(this);
    });
    Control.Layers = Layers;
    Control.Zoom = Zoom;
    Control.Scale = Scale;
    Control.Attribution = Attribution;
    control.layers = function(baseLayers, overlays, options) {
      return new Layers(baseLayers, overlays, options);
    };
    control.zoom = function(options) {
      return new Zoom(options);
    };
    control.scale = function(options) {
      return new Scale(options);
    };
    control.attribution = function(options) {
      return new Attribution(options);
    };
    var Handler = Class.extend({initialize:function(map) {
      this._map = map;
    }, enable:function() {
      if (this._enabled) {
        return this;
      }
      this._enabled = !0;
      this.addHooks();
      return this;
    }, disable:function() {
      if (!this._enabled) {
        return this;
      }
      this._enabled = !1;
      this.removeHooks();
      return this;
    }, enabled:function() {
      return !!this._enabled;
    }});
    Handler.addTo = function(map, name) {
      map.addHandler(name, this);
      return this;
    };
    var Mixin = {Events}, START = Browser.touch ? "touchstart mousedown" : "mousedown", Draggable = Evented.extend({options:{clickTolerance:3}, initialize:function(element, dragStartTarget, preventOutline, options) {
      setOptions(this, options);
      this._element = element;
      this._dragStartTarget = dragStartTarget || element;
      this._preventOutline = preventOutline;
    }, enable:function() {
      this._enabled || (on(this._dragStartTarget, START, this._onDown, this), this._enabled = !0);
    }, disable:function() {
      this._enabled && (Draggable._dragging === this && this.finishDrag(!0), off(this._dragStartTarget, START, this._onDown, this), this._moved = this._enabled = !1);
    }, _onDown:function(e) {
      if (this._enabled && (this._moved = !1, !hasClass(this._element, "leaflet-zoom-anim"))) {
        if (e.touches && e.touches.length !== 1) {
          Draggable._dragging === this && this.finishDrag();
        } else {
          if (!(Draggable._dragging || e.shiftKey || e.which !== 1 && e.button !== 1 && !e.touches || (Draggable._dragging = this, this._preventOutline && preventOutline(this._element), disableImageDrag(), disableTextSelection(), this._moving))) {
            this.fire("down");
            var first = e.touches ? e.touches[0] : e, sizedParent = getSizedParentNode(this._element);
            this._startPoint = new Point(first.clientX, first.clientY);
            this._startPos = getPosition(this._element);
            this._parentScale = getScale(sizedParent);
            e = e.type === "mousedown";
            on(document, e ? "mousemove" : "touchmove", this._onMove, this);
            on(document, e ? "mouseup" : "touchend touchcancel", this._onUp, this);
          }
        }
      }
    }, _onMove:function(e) {
      if (this._enabled) {
        if (e.touches && e.touches.length > 1) {
          this._moved = !0;
        } else {
          var first = e.touches && e.touches.length === 1 ? e.touches[0] : e;
          first = (new Point(first.clientX, first.clientY))._subtract(this._startPoint);
          !first.x && !first.y || Math.abs(first.x) + Math.abs(first.y) < this.options.clickTolerance || (first.x /= this._parentScale.x, first.y /= this._parentScale.y, preventDefault(e), this._moved || (this.fire("dragstart"), this._moved = !0, addClass(document.body, "leaflet-dragging"), this._lastTarget = e.target || e.srcElement, window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance && (this._lastTarget = this._lastTarget.correspondingUseElement), addClass(this._lastTarget, 
          "leaflet-drag-target")), this._newPos = this._startPos.add(first), this._moving = !0, this._lastEvent = e, this._updatePosition());
        }
      }
    }, _updatePosition:function() {
      var e = {originalEvent:this._lastEvent};
      this.fire("predrag", e);
      setPosition(this._element, this._newPos);
      this.fire("drag", e);
    }, _onUp:function() {
      this._enabled && this.finishDrag();
    }, finishDrag:function(noInertia) {
      removeClass(document.body, "leaflet-dragging");
      this._lastTarget && (removeClass(this._lastTarget, "leaflet-drag-target"), this._lastTarget = null);
      off(document, "mousemove touchmove", this._onMove, this);
      off(document, "mouseup touchend touchcancel", this._onUp, this);
      enableImageDrag();
      enableTextSelection();
      var fireDragend = this._moved && this._moving;
      this._moving = !1;
      Draggable._dragging = !1;
      fireDragend && this.fire("dragend", {noInertia, distance:this._newPos.distanceTo(this._startPos)});
    }}), PolyUtil = {__proto__:null, clipPolygon, polygonCenter, centroid}, _lastCode, LineUtil = {__proto__:null, simplify, pointToSegmentDistance, closestPointOnSegment:function(p, p1, p2) {
      return _sqClosestPointOnSegment(p, p1, p2);
    }, clipSegment, _getEdgeIntersection, _getBitCode, _sqClosestPointOnSegment, isFlat, _flat, polylineCenter}, LonLat = {project:function(latlng) {
      return new Point(latlng.lng, latlng.lat);
    }, unproject:function(point) {
      return new LatLng(point.y, point.x);
    }, bounds:new Bounds([-180, -90], [180, 90])}, Mercator = {R:6378137, R_MINOR:6356752.314245179, bounds:new Bounds([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]), project:function(latlng) {
      var d = Math.PI / 180, r = this.R, y = latlng.lat * d, tmp = this.R_MINOR / r;
      tmp = Math.sqrt(1 - tmp * tmp);
      var con = tmp * Math.sin(y);
      y = -r * Math.log(Math.max(Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), tmp / 2), 1E-10));
      return new Point(latlng.lng * d * r, y);
    }, unproject:function(point) {
      var d = 180 / Math.PI, r = this.R, tmp = this.R_MINOR / r;
      tmp = Math.sqrt(1 - tmp * tmp);
      for (var ts = Math.exp(-point.y / r), phi = Math.PI / 2 - 2 * Math.atan(ts), i = 0, dphi = 0.1; i < 15 && Math.abs(dphi) > 1e-7; i++) {
        dphi = tmp * Math.sin(phi), dphi = Math.pow((1 - dphi) / (1 + dphi), tmp / 2), dphi = Math.PI / 2 - 2 * Math.atan(ts * dphi) - phi, phi += dphi;
      }
      return new LatLng(phi * d, point.x * d / r);
    }}, index = {__proto__:null, LonLat, Mercator, SphericalMercator}, EPSG3395 = extend({}, Earth, {code:"EPSG:3395", projection:Mercator, transformation:function() {
      var scale = 0.5 / (Math.PI * Mercator.R);
      return toTransformation(scale, 0.5, -scale, 0.5);
    }()}), EPSG4326 = extend({}, Earth, {code:"EPSG:4326", projection:LonLat, transformation:toTransformation(1 / 180, 1, -1 / 180, 0.5)}), Simple = extend({}, CRS, {projection:LonLat, transformation:toTransformation(1, 0, -1, 0), scale:function(zoom) {
      return Math.pow(2, zoom);
    }, zoom:function(scale) {
      return Math.log(scale) / Math.LN2;
    }, distance:function(latlng1, latlng2) {
      var dx = latlng2.lng - latlng1.lng;
      latlng1 = latlng2.lat - latlng1.lat;
      return Math.sqrt(dx * dx + latlng1 * latlng1);
    }, infinite:!0});
    CRS.Earth = Earth;
    CRS.EPSG3395 = EPSG3395;
    CRS.EPSG3857 = EPSG3857;
    CRS.EPSG900913 = EPSG900913;
    CRS.EPSG4326 = EPSG4326;
    CRS.Simple = Simple;
    var Layer = Evented.extend({options:{pane:"overlayPane", attribution:null, bubblingMouseEvents:!0}, addTo:function(map) {
      map.addLayer(this);
      return this;
    }, remove:function() {
      return this.removeFrom(this._map || this._mapToAdd);
    }, removeFrom:function(obj) {
      obj && obj.removeLayer(this);
      return this;
    }, getPane:function(name) {
      return this._map.getPane(name ? this.options[name] || name : this.options.pane);
    }, addInteractiveTarget:function(targetEl) {
      this._map._targets[stamp(targetEl)] = this;
      return this;
    }, removeInteractiveTarget:function(targetEl) {
      delete this._map._targets[stamp(targetEl)];
      return this;
    }, getAttribution:function() {
      return this.options.attribution;
    }, _layerAdd:function(e) {
      var map = e.target;
      if (map.hasLayer(this)) {
        this._map = map;
        this._zoomAnimated = map._zoomAnimated;
        if (this.getEvents) {
          var events = this.getEvents();
          map.on(events, this);
          this.once("remove", function() {
            map.off(events, this);
          }, this);
        }
        this.onAdd(map);
        this.fire("add");
        map.fire("layeradd", {layer:this});
      }
    }});
    Map.include({addLayer:function(layer) {
      if (!layer._layerAdd) {
        throw Error("The provided object is not a Layer.");
      }
      var id = stamp(layer);
      if (this._layers[id]) {
        return this;
      }
      this._layers[id] = layer;
      layer._mapToAdd = this;
      layer.beforeAdd && layer.beforeAdd(this);
      this.whenReady(layer._layerAdd, layer);
      return this;
    }, removeLayer:function(layer) {
      var id = stamp(layer);
      if (!this._layers[id]) {
        return this;
      }
      if (this._loaded) {
        layer.onRemove(this);
      }
      delete this._layers[id];
      this._loaded && (this.fire("layerremove", {layer}), layer.fire("remove"));
      layer._map = layer._mapToAdd = null;
      return this;
    }, hasLayer:function(layer) {
      return stamp(layer) in this._layers;
    }, eachLayer:function(method, context) {
      for (var i in this._layers) {
        method.call(context, this._layers[i]);
      }
      return this;
    }, _addLayers:function(layers) {
      layers = layers ? isArray(layers) ? layers : [layers] : [];
      for (var i = 0, len = layers.length; i < len; i++) {
        this.addLayer(layers[i]);
      }
    }, _addZoomLimit:function(layer) {
      isNaN(layer.options.maxZoom) && isNaN(layer.options.minZoom) || (this._zoomBoundLayers[stamp(layer)] = layer, this._updateZoomLevels());
    }, _removeZoomLimit:function(layer) {
      layer = stamp(layer);
      this._zoomBoundLayers[layer] && (delete this._zoomBoundLayers[layer], this._updateZoomLevels());
    }, _updateZoomLevels:function() {
      var minZoom = Infinity, maxZoom = -Infinity, oldZoomSpan = this._getZoomSpan(), i;
      for (i in this._zoomBoundLayers) {
        var options = this._zoomBoundLayers[i].options;
        minZoom = options.minZoom === void 0 ? minZoom : Math.min(minZoom, options.minZoom);
        maxZoom = options.maxZoom === void 0 ? maxZoom : Math.max(maxZoom, options.maxZoom);
      }
      this._layersMaxZoom = maxZoom === -Infinity ? void 0 : maxZoom;
      this._layersMinZoom = minZoom === Infinity ? void 0 : minZoom;
      oldZoomSpan !== this._getZoomSpan() && this.fire("zoomlevelschange");
      this.options.maxZoom === void 0 && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom && this.setZoom(this._layersMaxZoom);
      this.options.minZoom === void 0 && this._layersMinZoom && this.getZoom() < this._layersMinZoom && this.setZoom(this._layersMinZoom);
    }});
    var LayerGroup = Layer.extend({initialize:function(layers, options) {
      setOptions(this, options);
      this._layers = {};
      var len;
      if (layers) {
        for (options = 0, len = layers.length; options < len; options++) {
          this.addLayer(layers[options]);
        }
      }
    }, addLayer:function(layer) {
      var id = this.getLayerId(layer);
      this._layers[id] = layer;
      this._map && this._map.addLayer(layer);
      return this;
    }, removeLayer:function(layer) {
      layer = layer in this._layers ? layer : this.getLayerId(layer);
      this._map && this._layers[layer] && this._map.removeLayer(this._layers[layer]);
      delete this._layers[layer];
      return this;
    }, hasLayer:function(layer) {
      return (typeof layer === "number" ? layer : this.getLayerId(layer)) in this._layers;
    }, clearLayers:function() {
      return this.eachLayer(this.removeLayer, this);
    }, invoke:function(methodName) {
      var args = Array.prototype.slice.call(arguments, 1), i;
      for (i in this._layers) {
        var layer = this._layers[i];
        layer[methodName] && layer[methodName].apply(layer, args);
      }
      return this;
    }, onAdd:function(map) {
      this.eachLayer(map.addLayer, map);
    }, onRemove:function(map) {
      this.eachLayer(map.removeLayer, map);
    }, eachLayer:function(method, context) {
      for (var i in this._layers) {
        method.call(context, this._layers[i]);
      }
      return this;
    }, getLayer:function(id) {
      return this._layers[id];
    }, getLayers:function() {
      var layers = [];
      this.eachLayer(layers.push, layers);
      return layers;
    }, setZIndex:function(zIndex) {
      return this.invoke("setZIndex", zIndex);
    }, getLayerId:function(layer) {
      return stamp(layer);
    }}), FeatureGroup = LayerGroup.extend({addLayer:function(layer) {
      if (this.hasLayer(layer)) {
        return this;
      }
      layer.addEventParent(this);
      LayerGroup.prototype.addLayer.call(this, layer);
      return this.fire("layeradd", {layer});
    }, removeLayer:function(layer) {
      if (!this.hasLayer(layer)) {
        return this;
      }
      layer in this._layers && (layer = this._layers[layer]);
      layer.removeEventParent(this);
      LayerGroup.prototype.removeLayer.call(this, layer);
      return this.fire("layerremove", {layer});
    }, setStyle:function(style) {
      return this.invoke("setStyle", style);
    }, bringToFront:function() {
      return this.invoke("bringToFront");
    }, bringToBack:function() {
      return this.invoke("bringToBack");
    }, getBounds:function() {
      var bounds = new LatLngBounds(), id;
      for (id in this._layers) {
        var layer = this._layers[id];
        bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
      }
      return bounds;
    }}), Icon = Class.extend({options:{popupAnchor:[0, 0], tooltipAnchor:[0, 0], crossOrigin:!1}, initialize:function(options) {
      setOptions(this, options);
    }, createIcon:function(oldIcon) {
      return this._createIcon("icon", oldIcon);
    }, createShadow:function(oldIcon) {
      return this._createIcon("shadow", oldIcon);
    }, _createIcon:function(name, oldIcon) {
      var src = this._getIconUrl(name);
      if (!src) {
        if (name === "icon") {
          throw Error("iconUrl not set in Icon options (see the docs).");
        }
        return null;
      }
      oldIcon = this._createImg(src, oldIcon && oldIcon.tagName === "IMG" ? oldIcon : null);
      this._setIconStyles(oldIcon, name);
      if (this.options.crossOrigin || this.options.crossOrigin === "") {
        oldIcon.crossOrigin = this.options.crossOrigin === !0 ? "" : this.options.crossOrigin;
      }
      return oldIcon;
    }, _setIconStyles:function(img, name) {
      var options = this.options, sizeOption = options[name + "Size"];
      typeof sizeOption === "number" && (sizeOption = [sizeOption, sizeOption]);
      sizeOption = toPoint(sizeOption);
      var anchor = toPoint(name === "shadow" && options.shadowAnchor || options.iconAnchor || sizeOption && sizeOption.divideBy(2, !0));
      img.className = "leaflet-marker-" + name + " " + (options.className || "");
      anchor && (img.style.marginLeft = -anchor.x + "px", img.style.marginTop = -anchor.y + "px");
      sizeOption && (img.style.width = sizeOption.x + "px", img.style.height = sizeOption.y + "px");
    }, _createImg:function(src, el) {
      el = el || document.createElement("img");
      el.src = src;
      return el;
    }, _getIconUrl:function(name) {
      return Browser.retina && this.options[name + "RetinaUrl"] || this.options[name + "Url"];
    }}), IconDefault = Icon.extend({options:{iconUrl:"marker-icon.png", iconRetinaUrl:"marker-icon-2x.png", shadowUrl:"marker-shadow.png", iconSize:[25, 41], iconAnchor:[12, 41], popupAnchor:[1, -34], tooltipAnchor:[16, -28], shadowSize:[41, 41]}, _getIconUrl:function(name) {
      typeof IconDefault.imagePath !== "string" && (IconDefault.imagePath = this._detectIconPath());
      return (this.options.imagePath || IconDefault.imagePath) + Icon.prototype._getIconUrl.call(this, name);
    }, _stripUrl:function(path) {
      path = (path = /^url\((['"])?(.+)\1\)$/.exec(path)) && path[2];
      var JSCompiler_temp;
      if (JSCompiler_temp = path) {
        JSCompiler_temp = (path = /^(.*)marker-icon\.png$/.exec(path)) && path[1];
      }
      return JSCompiler_temp;
    }, _detectIconPath:function() {
      var el = create$1("div", "leaflet-default-icon-path", document.body), path = getStyle(el, "background-image") || getStyle(el, "backgroundImage");
      document.body.removeChild(el);
      return (path = this._stripUrl(path)) ? path : (el = document.querySelector('link[href$\x3d"leaflet.css"]')) ? el.href.substring(0, el.href.length - 11 - 1) : "";
    }}), MarkerDrag = Handler.extend({initialize:function(marker) {
      this._marker = marker;
    }, addHooks:function() {
      var icon = this._marker._icon;
      this._draggable || (this._draggable = new Draggable(icon, icon, !0));
      this._draggable.on({dragstart:this._onDragStart, predrag:this._onPreDrag, drag:this._onDrag, dragend:this._onDragEnd}, this).enable();
      addClass(icon, "leaflet-marker-draggable");
    }, removeHooks:function() {
      this._draggable.off({dragstart:this._onDragStart, predrag:this._onPreDrag, drag:this._onDrag, dragend:this._onDragEnd}, this).disable();
      this._marker._icon && removeClass(this._marker._icon, "leaflet-marker-draggable");
    }, moved:function() {
      return this._draggable && this._draggable._moved;
    }, _adjustPan:function(e) {
      var marker = this._marker, map = marker._map, speed = this._marker.options.autoPanSpeed, padding = this._marker.options.autoPanPadding, iconPos = getPosition(marker._icon), bounds = map.getPixelBounds(), origin = map.getPixelOrigin();
      padding = toBounds(bounds.min._subtract(origin).add(padding), bounds.max._subtract(origin).subtract(padding));
      padding.contains(iconPos) || (speed = toPoint((Math.max(padding.max.x, iconPos.x) - padding.max.x) / (bounds.max.x - padding.max.x) - (Math.min(padding.min.x, iconPos.x) - padding.min.x) / (bounds.min.x - padding.min.x), (Math.max(padding.max.y, iconPos.y) - padding.max.y) / (bounds.max.y - padding.max.y) - (Math.min(padding.min.y, iconPos.y) - padding.min.y) / (bounds.min.y - padding.min.y)).multiplyBy(speed), map.panBy(speed, {animate:!1}), this._draggable._newPos._add(speed), this._draggable._startPos._add(speed), 
      setPosition(marker._icon, this._draggable._newPos), this._onDrag(e), this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e)));
    }, _onDragStart:function() {
      this._oldLatLng = this._marker.getLatLng();
      this._marker.closePopup && this._marker.closePopup();
      this._marker.fire("movestart").fire("dragstart");
    }, _onPreDrag:function(e) {
      this._marker.options.autoPan && (cancelAnimFrame(this._panRequest), this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e)));
    }, _onDrag:function(e) {
      var marker = this._marker, shadow = marker._shadow, iconPos = getPosition(marker._icon), latlng = marker._map.layerPointToLatLng(iconPos);
      shadow && setPosition(shadow, iconPos);
      marker._latlng = latlng;
      e.latlng = latlng;
      e.oldLatLng = this._oldLatLng;
      marker.fire("move", e).fire("drag", e);
    }, _onDragEnd:function(e) {
      cancelAnimFrame(this._panRequest);
      delete this._oldLatLng;
      this._marker.fire("moveend").fire("dragend", e);
    }}), Marker = Layer.extend({options:{icon:new IconDefault(), interactive:!0, keyboard:!0, title:"", alt:"Marker", zIndexOffset:0, opacity:1, riseOnHover:!1, riseOffset:250, pane:"markerPane", shadowPane:"shadowPane", bubblingMouseEvents:!1, autoPanOnFocus:!0, draggable:!1, autoPan:!1, autoPanPadding:[50, 50], autoPanSpeed:10}, initialize:function(latlng, options) {
      setOptions(this, options);
      this._latlng = toLatLng(latlng);
    }, onAdd:function(map) {
      if (this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation) {
        map.on("zoomanim", this._animateZoom, this);
      }
      this._initIcon();
      this.update();
    }, onRemove:function(map) {
      this.dragging && this.dragging.enabled() && (this.options.draggable = !0, this.dragging.removeHooks());
      delete this.dragging;
      this._zoomAnimated && map.off("zoomanim", this._animateZoom, this);
      this._removeIcon();
      this._removeShadow();
    }, getEvents:function() {
      return {zoom:this.update, viewreset:this.update};
    }, getLatLng:function() {
      return this._latlng;
    }, setLatLng:function(latlng) {
      var oldLatLng = this._latlng;
      this._latlng = toLatLng(latlng);
      this.update();
      return this.fire("move", {oldLatLng, latlng:this._latlng});
    }, setZIndexOffset:function(offset) {
      this.options.zIndexOffset = offset;
      return this.update();
    }, getIcon:function() {
      return this.options.icon;
    }, setIcon:function(icon) {
      this.options.icon = icon;
      this._map && (this._initIcon(), this.update());
      this._popup && this.bindPopup(this._popup, this._popup.options);
      return this;
    }, getElement:function() {
      return this._icon;
    }, update:function() {
      if (this._icon && this._map) {
        var pos = this._map.latLngToLayerPoint(this._latlng).round();
        this._setPos(pos);
      }
      return this;
    }, _initIcon:function() {
      var options = this.options, classToAdd = "leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide"), icon = options.icon.createIcon(this._icon), addIcon = !1;
      icon !== this._icon && (this._icon && this._removeIcon(), addIcon = !0, options.title && (icon.title = options.title), icon.tagName === "IMG" && (icon.alt = options.alt || ""));
      addClass(icon, classToAdd);
      options.keyboard && (icon.tabIndex = "0", icon.setAttribute("role", "button"));
      this._icon = icon;
      if (options.riseOnHover) {
        this.on({mouseover:this._bringToFront, mouseout:this._resetZIndex});
      }
      this.options.autoPanOnFocus && on(icon, "focus", this._panOnFocus, this);
      icon = options.icon.createShadow(this._shadow);
      var addShadow = !1;
      icon !== this._shadow && (this._removeShadow(), addShadow = !0);
      icon && (addClass(icon, classToAdd), icon.alt = "");
      this._shadow = icon;
      options.opacity < 1 && this._updateOpacity();
      addIcon && this.getPane().appendChild(this._icon);
      this._initInteraction();
      icon && addShadow && this.getPane(options.shadowPane).appendChild(this._shadow);
    }, _removeIcon:function() {
      this.options.riseOnHover && this.off({mouseover:this._bringToFront, mouseout:this._resetZIndex});
      this.options.autoPanOnFocus && off(this._icon, "focus", this._panOnFocus, this);
      remove(this._icon);
      this.removeInteractiveTarget(this._icon);
      this._icon = null;
    }, _removeShadow:function() {
      this._shadow && remove(this._shadow);
      this._shadow = null;
    }, _setPos:function(pos) {
      this._icon && setPosition(this._icon, pos);
      this._shadow && setPosition(this._shadow, pos);
      this._zIndex = pos.y + this.options.zIndexOffset;
      this._resetZIndex();
    }, _updateZIndex:function(offset) {
      this._icon && (this._icon.style.zIndex = this._zIndex + offset);
    }, _animateZoom:function(opt) {
      opt = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();
      this._setPos(opt);
    }, _initInteraction:function() {
      if (this.options.interactive && (addClass(this._icon, "leaflet-interactive"), this.addInteractiveTarget(this._icon), MarkerDrag)) {
        var draggable = this.options.draggable;
        this.dragging && (draggable = this.dragging.enabled(), this.dragging.disable());
        this.dragging = new MarkerDrag(this);
        draggable && this.dragging.enable();
      }
    }, setOpacity:function(opacity) {
      this.options.opacity = opacity;
      this._map && this._updateOpacity();
      return this;
    }, _updateOpacity:function() {
      var opacity = this.options.opacity;
      this._icon && setOpacity(this._icon, opacity);
      this._shadow && setOpacity(this._shadow, opacity);
    }, _bringToFront:function() {
      this._updateZIndex(this.options.riseOffset);
    }, _resetZIndex:function() {
      this._updateZIndex(0);
    }, _panOnFocus:function() {
      var map = this._map;
      if (map) {
        var iconOpts = this.options.icon.options, size = iconOpts.iconSize ? toPoint(iconOpts.iconSize) : toPoint(0, 0);
        iconOpts = iconOpts.iconAnchor ? toPoint(iconOpts.iconAnchor) : toPoint(0, 0);
        map.panInside(this._latlng, {paddingTopLeft:iconOpts, paddingBottomRight:size.subtract(iconOpts)});
      }
    }, _getPopupAnchor:function() {
      return this.options.icon.options.popupAnchor;
    }, _getTooltipAnchor:function() {
      return this.options.icon.options.tooltipAnchor;
    }}), Path = Layer.extend({options:{stroke:!0, color:"#3388ff", weight:3, opacity:1, lineCap:"round", lineJoin:"round", dashArray:null, dashOffset:null, fill:!1, fillColor:null, fillOpacity:0.2, fillRule:"evenodd", interactive:!0, bubblingMouseEvents:!0}, beforeAdd:function(map) {
      this._renderer = map.getRenderer(this);
    }, onAdd:function() {
      this._renderer._initPath(this);
      this._reset();
      this._renderer._addPath(this);
    }, onRemove:function() {
      this._renderer._removePath(this);
    }, redraw:function() {
      this._map && this._renderer._updatePath(this);
      return this;
    }, setStyle:function(style) {
      setOptions(this, style);
      this._renderer && (this._renderer._updateStyle(this), this.options.stroke && style && Object.prototype.hasOwnProperty.call(style, "weight") && this._updateBounds());
      return this;
    }, bringToFront:function() {
      this._renderer && this._renderer._bringToFront(this);
      return this;
    }, bringToBack:function() {
      this._renderer && this._renderer._bringToBack(this);
      return this;
    }, getElement:function() {
      return this._path;
    }, _reset:function() {
      this._project();
      this._update();
    }, _clickTolerance:function() {
      return (this.options.stroke ? this.options.weight / 2 : 0) + (this._renderer.options.tolerance || 0);
    }}), CircleMarker = Path.extend({options:{fill:!0, radius:10}, initialize:function(latlng, options) {
      setOptions(this, options);
      this._latlng = toLatLng(latlng);
      this._radius = this.options.radius;
    }, setLatLng:function(latlng) {
      var oldLatLng = this._latlng;
      this._latlng = toLatLng(latlng);
      this.redraw();
      return this.fire("move", {oldLatLng, latlng:this._latlng});
    }, getLatLng:function() {
      return this._latlng;
    }, setRadius:function(radius) {
      this.options.radius = this._radius = radius;
      return this.redraw();
    }, getRadius:function() {
      return this._radius;
    }, setStyle:function(options) {
      var radius = options && options.radius || this._radius;
      Path.prototype.setStyle.call(this, options);
      this.setRadius(radius);
      return this;
    }, _project:function() {
      this._point = this._map.latLngToLayerPoint(this._latlng);
      this._updateBounds();
    }, _updateBounds:function() {
      var r = this._radius, r2 = this._radiusY || r, w = this._clickTolerance();
      r = [r + w, r2 + w];
      this._pxBounds = new Bounds(this._point.subtract(r), this._point.add(r));
    }, _update:function() {
      this._map && this._updatePath();
    }, _updatePath:function() {
      this._renderer._updateCircle(this);
    }, _empty:function() {
      return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
    }, _containsPoint:function(p) {
      return p.distanceTo(this._point) <= this._radius + this._clickTolerance();
    }}), Circle = CircleMarker.extend({initialize:function(latlng, options, legacyOptions) {
      typeof options === "number" && (options = extend({}, legacyOptions, {radius:options}));
      setOptions(this, options);
      this._latlng = toLatLng(latlng);
      if (isNaN(this.options.radius)) {
        throw Error("Circle radius cannot be NaN");
      }
      this._mRadius = this.options.radius;
    }, setRadius:function(radius) {
      this._mRadius = radius;
      return this.redraw();
    }, getRadius:function() {
      return this._mRadius;
    }, getBounds:function() {
      var half = [this._radius, this._radiusY || this._radius];
      return new LatLngBounds(this._map.layerPointToLatLng(this._point.subtract(half)), this._map.layerPointToLatLng(this._point.add(half)));
    }, setStyle:Path.prototype.setStyle, _project:function() {
      var lng = this._latlng.lng, lat = this._latlng.lat, map = this._map, crs = map.options.crs;
      if (crs.distance === Earth.distance) {
        var d = Math.PI / 180;
        crs = this._mRadius / Earth.R / d;
        var top = map.project([lat + crs, lng]), bottom = map.project([lat - crs, lng]);
        bottom = top.add(bottom).divideBy(2);
        var lat2 = map.unproject(bottom).lat;
        d = Math.acos((Math.cos(crs * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) / (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;
        if (isNaN(d) || d === 0) {
          d = crs / Math.cos(Math.PI / 180 * lat);
        }
        this._point = bottom.subtract(map.getPixelOrigin());
        this._radius = isNaN(d) ? 0 : bottom.x - map.project([lat2, lng - d]).x;
        this._radiusY = bottom.y - top.y;
      } else {
        lng = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0])), this._point = map.latLngToLayerPoint(this._latlng), this._radius = this._point.x - map.latLngToLayerPoint(lng).x;
      }
      this._updateBounds();
    }}), Polyline = Path.extend({options:{smoothFactor:1.0, noClip:!1}, initialize:function(latlngs, options) {
      setOptions(this, options);
      this._setLatLngs(latlngs);
    }, getLatLngs:function() {
      return this._latlngs;
    }, setLatLngs:function(latlngs) {
      this._setLatLngs(latlngs);
      return this.redraw();
    }, isEmpty:function() {
      return !this._latlngs.length;
    }, closestLayerPoint:function(p) {
      for (var minDistance = Infinity, minPoint = null, closest = _sqClosestPointOnSegment, p1, p2, j = 0, jLen = this._parts.length; j < jLen; j++) {
        for (var points = this._parts[j], i = 1, len = points.length; i < len; i++) {
          p1 = points[i - 1];
          p2 = points[i];
          var sqDist = closest(p, p1, p2, !0);
          sqDist < minDistance && (minDistance = sqDist, minPoint = closest(p, p1, p2));
        }
      }
      minPoint && (minPoint.distance = Math.sqrt(minDistance));
      return minPoint;
    }, getCenter:function() {
      if (!this._map) {
        throw Error("Must add layer to map before using getCenter()");
      }
      return polylineCenter(this._defaultShape(), this._map.options.crs);
    }, getBounds:function() {
      return this._bounds;
    }, addLatLng:function(latlng, latlngs) {
      latlngs = latlngs || this._defaultShape();
      latlng = toLatLng(latlng);
      latlngs.push(latlng);
      this._bounds.extend(latlng);
      return this.redraw();
    }, _setLatLngs:function(latlngs) {
      this._bounds = new LatLngBounds();
      this._latlngs = this._convertLatLngs(latlngs);
    }, _defaultShape:function() {
      return isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];
    }, _convertLatLngs:function(latlngs) {
      for (var result = [], flat = isFlat(latlngs), i = 0, len = latlngs.length; i < len; i++) {
        flat ? (result[i] = toLatLng(latlngs[i]), this._bounds.extend(result[i])) : result[i] = this._convertLatLngs(latlngs[i]);
      }
      return result;
    }, _project:function() {
      var pxBounds = new Bounds();
      this._rings = [];
      this._projectLatlngs(this._latlngs, this._rings, pxBounds);
      this._bounds.isValid() && pxBounds.isValid() && (this._rawPxBounds = pxBounds, this._updateBounds());
    }, _updateBounds:function() {
      var w = this._clickTolerance();
      w = new Point(w, w);
      this._rawPxBounds && (this._pxBounds = new Bounds([this._rawPxBounds.min.subtract(w), this._rawPxBounds.max.add(w)]));
    }, _projectLatlngs:function(latlngs, result, projectedBounds) {
      var len = latlngs.length, i;
      if (latlngs[0] instanceof LatLng) {
        var ring = [];
        for (i = 0; i < len; i++) {
          ring[i] = this._map.latLngToLayerPoint(latlngs[i]), projectedBounds.extend(ring[i]);
        }
        result.push(ring);
      } else {
        for (i = 0; i < len; i++) {
          this._projectLatlngs(latlngs[i], result, projectedBounds);
        }
      }
    }, _clipPoints:function() {
      var bounds = this._renderer._bounds;
      this._parts = [];
      if (this._pxBounds && this._pxBounds.intersects(bounds)) {
        if (this.options.noClip) {
          this._parts = this._rings;
        } else {
          var parts = this._parts, i, len, len2, segment;
          var k = i = 0;
          for (len = this._rings.length; i < len; i++) {
            var points = this._rings[i];
            var j = 0;
            for (len2 = points.length; j < len2 - 1; j++) {
              if (segment = clipSegment(points[j], points[j + 1], bounds, j, !0)) {
                if (parts[k] = parts[k] || [], parts[k].push(segment[0]), segment[1] !== points[j + 1] || j === len2 - 2) {
                  parts[k].push(segment[1]), k++;
                }
              }
            }
          }
        }
      }
    }, _simplifyPoints:function() {
      for (var parts = this._parts, tolerance = this.options.smoothFactor, i = 0, len = parts.length; i < len; i++) {
        parts[i] = simplify(parts[i], tolerance);
      }
    }, _update:function() {
      this._map && (this._clipPoints(), this._simplifyPoints(), this._updatePath());
    }, _updatePath:function() {
      this._renderer._updatePoly(this);
    }, _containsPoint:function(p, closed) {
      var k, len, w = this._clickTolerance();
      if (!this._pxBounds || !this._pxBounds.contains(p)) {
        return !1;
      }
      var i = 0;
      for (len = this._parts.length; i < len; i++) {
        var part = this._parts[i];
        var j = 0;
        var len2 = part.length;
        for (k = len2 - 1; j < len2; k = j++) {
          if ((closed || j !== 0) && pointToSegmentDistance(p, part[k], part[j]) <= w) {
            return !0;
          }
        }
      }
      return !1;
    }});
    Polyline._flat = _flat;
    var Polygon = Polyline.extend({options:{fill:!0}, isEmpty:function() {
      return !this._latlngs.length || !this._latlngs[0].length;
    }, getCenter:function() {
      if (!this._map) {
        throw Error("Must add layer to map before using getCenter()");
      }
      return polygonCenter(this._defaultShape(), this._map.options.crs);
    }, _convertLatLngs:function(latlngs) {
      latlngs = Polyline.prototype._convertLatLngs.call(this, latlngs);
      var len = latlngs.length;
      len >= 2 && latlngs[0] instanceof LatLng && latlngs[0].equals(latlngs[len - 1]) && latlngs.pop();
      return latlngs;
    }, _setLatLngs:function(latlngs) {
      Polyline.prototype._setLatLngs.call(this, latlngs);
      isFlat(this._latlngs) && (this._latlngs = [this._latlngs]);
    }, _defaultShape:function() {
      return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
    }, _clipPoints:function() {
      var bounds = this._renderer._bounds, w = this.options.weight;
      w = new Point(w, w);
      bounds = new Bounds(bounds.min.subtract(w), bounds.max.add(w));
      this._parts = [];
      if (this._pxBounds && this._pxBounds.intersects(bounds)) {
        if (this.options.noClip) {
          this._parts = this._rings;
        } else {
          w = 0;
          for (var len = this._rings.length, clipped; w < len; w++) {
            clipped = clipPolygon(this._rings[w], bounds, !0), clipped.length && this._parts.push(clipped);
          }
        }
      }
    }, _updatePath:function() {
      this._renderer._updatePoly(this, !0);
    }, _containsPoint:function(p) {
      var inside = !1, p2, len;
      if (!this._pxBounds || !this._pxBounds.contains(p)) {
        return !1;
      }
      var i = 0;
      for (len = this._parts.length; i < len; i++) {
        var part = this._parts[i];
        var j = 0;
        var len2 = part.length;
        for (p2 = len2 - 1; j < len2; p2 = j++) {
          var p1 = part[j];
          p2 = part[p2];
          p1.y > p.y !== p2.y > p.y && p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x && (inside = !inside);
        }
      }
      return inside || Polyline.prototype._containsPoint.call(this, p, !0);
    }}), GeoJSON = FeatureGroup.extend({initialize:function(geojson, options) {
      setOptions(this, options);
      this._layers = {};
      geojson && this.addData(geojson);
    }, addData:function(geojson) {
      var features = isArray(geojson) ? geojson : geojson.features, len;
      if (features) {
        geojson = 0;
        for (len = features.length; geojson < len; geojson++) {
          var feature = features[geojson];
          (feature.geometries || feature.geometry || feature.features || feature.coordinates) && this.addData(feature);
        }
        return this;
      }
      features = this.options;
      if (features.filter && !features.filter(geojson)) {
        return this;
      }
      len = geometryToLayer(geojson, features);
      if (!len) {
        return this;
      }
      len.feature = asFeature(geojson);
      len.defaultOptions = len.options;
      this.resetStyle(len);
      if (features.onEachFeature) {
        features.onEachFeature(geojson, len);
      }
      return this.addLayer(len);
    }, resetStyle:function(layer) {
      if (layer === void 0) {
        return this.eachLayer(this.resetStyle, this);
      }
      layer.options = extend({}, layer.defaultOptions);
      this._setLayerStyle(layer, this.options.style);
      return this;
    }, setStyle:function(style) {
      return this.eachLayer(function(layer) {
        this._setLayerStyle(layer, style);
      }, this);
    }, _setLayerStyle:function(layer, style) {
      layer.setStyle && (typeof style === "function" && (style = style(layer.feature)), layer.setStyle(style));
    }}), PointToGeoJSON = {toGeoJSON:function(precision) {
      return getFeature(this, {type:"Point", coordinates:latLngToCoords(this.getLatLng(), precision)});
    }};
    Marker.include(PointToGeoJSON);
    Circle.include(PointToGeoJSON);
    CircleMarker.include(PointToGeoJSON);
    Polyline.include({toGeoJSON:function(precision) {
      var multi = !isFlat(this._latlngs);
      precision = latLngsToCoords(this._latlngs, multi ? 1 : 0, !1, precision);
      return getFeature(this, {type:(multi ? "Multi" : "") + "LineString", coordinates:precision});
    }});
    Polygon.include({toGeoJSON:function(precision) {
      var holes = !isFlat(this._latlngs), multi = holes && !isFlat(this._latlngs[0]);
      precision = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, !0, precision);
      holes || (precision = [precision]);
      return getFeature(this, {type:(multi ? "Multi" : "") + "Polygon", coordinates:precision});
    }});
    LayerGroup.include({toMultiPoint:function(precision) {
      var coords = [];
      this.eachLayer(function(layer) {
        coords.push(layer.toGeoJSON(precision).geometry.coordinates);
      });
      return getFeature(this, {type:"MultiPoint", coordinates:coords});
    }, toGeoJSON:function(precision) {
      var type = this.feature && this.feature.geometry && this.feature.geometry.type;
      if (type === "MultiPoint") {
        return this.toMultiPoint(precision);
      }
      var isGeometryCollection = type === "GeometryCollection", jsons = [];
      this.eachLayer(function(layer) {
        layer.toGeoJSON && (layer = layer.toGeoJSON(precision), isGeometryCollection ? jsons.push(layer.geometry) : (layer = asFeature(layer), layer.type === "FeatureCollection" ? jsons.push.apply(jsons, layer.features) : jsons.push(layer)));
      });
      return isGeometryCollection ? getFeature(this, {geometries:jsons, type:"GeometryCollection"}) : {type:"FeatureCollection", features:jsons};
    }});
    var ImageOverlay = Layer.extend({options:{opacity:1, alt:"", interactive:!1, crossOrigin:!1, errorOverlayUrl:"", zIndex:1, className:""}, initialize:function(url, bounds, options) {
      this._url = url;
      this._bounds = toLatLngBounds(bounds);
      setOptions(this, options);
    }, onAdd:function() {
      this._image || (this._initImage(), this.options.opacity < 1 && this._updateOpacity());
      this.options.interactive && (addClass(this._image, "leaflet-interactive"), this.addInteractiveTarget(this._image));
      this.getPane().appendChild(this._image);
      this._reset();
    }, onRemove:function() {
      remove(this._image);
      this.options.interactive && this.removeInteractiveTarget(this._image);
    }, setOpacity:function(opacity) {
      this.options.opacity = opacity;
      this._image && this._updateOpacity();
      return this;
    }, setStyle:function(styleOpts) {
      styleOpts.opacity && this.setOpacity(styleOpts.opacity);
      return this;
    }, bringToFront:function() {
      this._map && toFront(this._image);
      return this;
    }, bringToBack:function() {
      this._map && toBack(this._image);
      return this;
    }, setUrl:function(url) {
      this._url = url;
      this._image && (this._image.src = url);
      return this;
    }, setBounds:function(bounds) {
      this._bounds = toLatLngBounds(bounds);
      this._map && this._reset();
      return this;
    }, getEvents:function() {
      var events = {zoom:this._reset, viewreset:this._reset};
      this._zoomAnimated && (events.zoomanim = this._animateZoom);
      return events;
    }, setZIndex:function(value) {
      this.options.zIndex = value;
      this._updateZIndex();
      return this;
    }, getBounds:function() {
      return this._bounds;
    }, getElement:function() {
      return this._image;
    }, _initImage:function() {
      var wasElementSupplied = this._url.tagName === "IMG", img = this._image = wasElementSupplied ? this._url : create$1("img");
      addClass(img, "leaflet-image-layer");
      this._zoomAnimated && addClass(img, "leaflet-zoom-animated");
      this.options.className && addClass(img, this.options.className);
      img.onselectstart = falseFn;
      img.onmousemove = falseFn;
      img.onload = bind(this.fire, this, "load");
      img.onerror = bind(this._overlayOnError, this, "error");
      if (this.options.crossOrigin || this.options.crossOrigin === "") {
        img.crossOrigin = this.options.crossOrigin === !0 ? "" : this.options.crossOrigin;
      }
      this.options.zIndex && this._updateZIndex();
      wasElementSupplied ? this._url = img.src : (img.src = this._url, img.alt = this.options.alt);
    }, _animateZoom:function(e) {
      var scale = this._map.getZoomScale(e.zoom);
      e = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;
      setTransform(this._image, e, scale);
    }, _reset:function() {
      var image = this._image, bounds = new Bounds(this._map.latLngToLayerPoint(this._bounds.getNorthWest()), this._map.latLngToLayerPoint(this._bounds.getSouthEast())), size = bounds.getSize();
      setPosition(image, bounds.min);
      image.style.width = size.x + "px";
      image.style.height = size.y + "px";
    }, _updateOpacity:function() {
      setOpacity(this._image, this.options.opacity);
    }, _updateZIndex:function() {
      this._image && this.options.zIndex !== void 0 && this.options.zIndex !== null && (this._image.style.zIndex = this.options.zIndex);
    }, _overlayOnError:function() {
      this.fire("error");
      var errorUrl = this.options.errorOverlayUrl;
      errorUrl && this._url !== errorUrl && (this._url = errorUrl, this._image.src = errorUrl);
    }, getCenter:function() {
      return this._bounds.getCenter();
    }}), VideoOverlay = ImageOverlay.extend({options:{autoplay:!0, loop:!0, keepAspectRatio:!0, muted:!1, playsInline:!0}, _initImage:function() {
      var wasElementSupplied = this._url.tagName === "VIDEO", vid = this._image = wasElementSupplied ? this._url : create$1("video");
      addClass(vid, "leaflet-image-layer");
      this._zoomAnimated && addClass(vid, "leaflet-zoom-animated");
      this.options.className && addClass(vid, this.options.className);
      vid.onselectstart = falseFn;
      vid.onmousemove = falseFn;
      vid.onloadeddata = bind(this.fire, this, "load");
      if (wasElementSupplied) {
        wasElementSupplied = vid.getElementsByTagName("source");
        for (var sources = [], j = 0; j < wasElementSupplied.length; j++) {
          sources.push(wasElementSupplied[j].src);
        }
        this._url = wasElementSupplied.length > 0 ? sources : [vid.src];
      } else {
        for (isArray(this._url) || (this._url = [this._url]), !this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(vid.style, "objectFit") && (vid.style.objectFit = "fill"), vid.autoplay = !!this.options.autoplay, vid.loop = !!this.options.loop, vid.muted = !!this.options.muted, vid.playsInline = !!this.options.playsInline, wasElementSupplied = 0; wasElementSupplied < this._url.length; wasElementSupplied++) {
          sources = create$1("source"), sources.src = this._url[wasElementSupplied], vid.appendChild(sources);
        }
      }
    }}), SVGOverlay = ImageOverlay.extend({_initImage:function() {
      var el = this._image = this._url;
      addClass(el, "leaflet-image-layer");
      this._zoomAnimated && addClass(el, "leaflet-zoom-animated");
      this.options.className && addClass(el, this.options.className);
      el.onselectstart = falseFn;
      el.onmousemove = falseFn;
    }}), DivOverlay = Layer.extend({options:{interactive:!1, offset:[0, 0], className:"", pane:void 0, content:""}, initialize:function(options, source) {
      options && (options instanceof LatLng || isArray(options)) ? (this._latlng = toLatLng(options), setOptions(this, source)) : (setOptions(this, options), this._source = source);
      this.options.content && (this._content = this.options.content);
    }, openOn:function(map) {
      map = arguments.length ? map : this._source._map;
      map.hasLayer(this) || map.addLayer(this);
      return this;
    }, close:function() {
      this._map && this._map.removeLayer(this);
      return this;
    }, toggle:function(layer) {
      this._map ? this.close() : (arguments.length ? this._source = layer : layer = this._source, this._prepareOpen(), this.openOn(layer._map));
      return this;
    }, onAdd:function(map) {
      this._zoomAnimated = map._zoomAnimated;
      this._container || this._initLayout();
      map._fadeAnimated && setOpacity(this._container, 0);
      clearTimeout(this._removeTimeout);
      this.getPane().appendChild(this._container);
      this.update();
      map._fadeAnimated && setOpacity(this._container, 1);
      this.bringToFront();
      this.options.interactive && (addClass(this._container, "leaflet-interactive"), this.addInteractiveTarget(this._container));
    }, onRemove:function(map) {
      map._fadeAnimated ? (setOpacity(this._container, 0), this._removeTimeout = setTimeout(bind(remove, void 0, this._container), 200)) : remove(this._container);
      this.options.interactive && (removeClass(this._container, "leaflet-interactive"), this.removeInteractiveTarget(this._container));
    }, getLatLng:function() {
      return this._latlng;
    }, setLatLng:function(latlng) {
      this._latlng = toLatLng(latlng);
      this._map && (this._updatePosition(), this._adjustPan());
      return this;
    }, getContent:function() {
      return this._content;
    }, setContent:function(content) {
      this._content = content;
      this.update();
      return this;
    }, getElement:function() {
      return this._container;
    }, update:function() {
      this._map && (this._container.style.visibility = "hidden", this._updateContent(), this._updateLayout(), this._updatePosition(), this._container.style.visibility = "", this._adjustPan());
    }, getEvents:function() {
      var events = {zoom:this._updatePosition, viewreset:this._updatePosition};
      this._zoomAnimated && (events.zoomanim = this._animateZoom);
      return events;
    }, isOpen:function() {
      return !!this._map && this._map.hasLayer(this);
    }, bringToFront:function() {
      this._map && toFront(this._container);
      return this;
    }, bringToBack:function() {
      this._map && toBack(this._container);
      return this;
    }, _prepareOpen:function(latlng) {
      var source = this._source;
      if (!source._map) {
        return !1;
      }
      if (source instanceof FeatureGroup) {
        source = null;
        var layers = this._source._layers, id;
        for (id in layers) {
          if (layers[id]._map) {
            source = layers[id];
            break;
          }
        }
        if (!source) {
          return !1;
        }
        this._source = source;
      }
      if (!latlng) {
        if (source.getCenter) {
          latlng = source.getCenter();
        } else if (source.getLatLng) {
          latlng = source.getLatLng();
        } else if (source.getBounds) {
          latlng = source.getBounds().getCenter();
        } else {
          throw Error("Unable to get source layer LatLng.");
        }
      }
      this.setLatLng(latlng);
      this._map && this.update();
      return !0;
    }, _updateContent:function() {
      if (this._content) {
        var node = this._contentNode, content = typeof this._content === "function" ? this._content(this._source || this) : this._content;
        if (typeof content === "string") {
          node.innerHTML = content;
        } else {
          for (; node.hasChildNodes();) {
            node.removeChild(node.firstChild);
          }
          node.appendChild(content);
        }
        this.fire("contentupdate");
      }
    }, _updatePosition:function() {
      if (this._map) {
        var pos = this._map.latLngToLayerPoint(this._latlng), offset = toPoint(this.options.offset), anchor = this._getAnchor();
        this._zoomAnimated ? setPosition(this._container, pos.add(anchor)) : offset = offset.add(pos).add(anchor);
        pos = this._containerBottom = -offset.y;
        offset = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;
        this._container.style.bottom = pos + "px";
        this._container.style.left = offset + "px";
      }
    }, _getAnchor:function() {
      return [0, 0];
    }});
    Map.include({_initOverlay:function(OverlayClass, content, latlng, options) {
      var overlay = content;
      overlay instanceof OverlayClass || (overlay = (new OverlayClass(options)).setContent(content));
      latlng && overlay.setLatLng(latlng);
      return overlay;
    }});
    Layer.include({_initOverlay:function(OverlayClass, old, content, options) {
      var overlay = content;
      overlay instanceof OverlayClass ? (setOptions(overlay, options), overlay._source = this) : (overlay = old && !options ? old : new OverlayClass(options, this), overlay.setContent(content));
      return overlay;
    }});
    var Popup = DivOverlay.extend({options:{pane:"popupPane", offset:[0, 7], maxWidth:300, minWidth:50, maxHeight:null, autoPan:!0, autoPanPaddingTopLeft:null, autoPanPaddingBottomRight:null, autoPanPadding:[5, 5], keepInView:!1, closeButton:!0, autoClose:!0, closeOnEscapeKey:!0, className:""}, openOn:function(map) {
      map = arguments.length ? map : this._source._map;
      !map.hasLayer(this) && map._popup && map._popup.options.autoClose && map.removeLayer(map._popup);
      map._popup = this;
      return DivOverlay.prototype.openOn.call(this, map);
    }, onAdd:function(map) {
      DivOverlay.prototype.onAdd.call(this, map);
      map.fire("popupopen", {popup:this});
      if (this._source && (this._source.fire("popupopen", {popup:this}, !0), !(this._source instanceof Path))) {
        this._source.on("preclick", stopPropagation);
      }
    }, onRemove:function(map) {
      DivOverlay.prototype.onRemove.call(this, map);
      map.fire("popupclose", {popup:this});
      this._source && (this._source.fire("popupclose", {popup:this}, !0), this._source instanceof Path || this._source.off("preclick", stopPropagation));
    }, getEvents:function() {
      var events = DivOverlay.prototype.getEvents.call(this);
      if (this.options.closeOnClick !== void 0 ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
        events.preclick = this.close;
      }
      this.options.keepInView && (events.moveend = this._adjustPan);
      return events;
    }, _initLayout:function() {
      var container = this._container = create$1("div", "leaflet-popup " + (this.options.className || "") + " leaflet-zoom-animated"), wrapper = this._wrapper = create$1("div", "leaflet-popup-content-wrapper", container);
      this._contentNode = create$1("div", "leaflet-popup-content", wrapper);
      disableClickPropagation(container);
      disableScrollPropagation(this._contentNode);
      on(container, "contextmenu", stopPropagation);
      this._tipContainer = create$1("div", "leaflet-popup-tip-container", container);
      this._tip = create$1("div", "leaflet-popup-tip", this._tipContainer);
      this.options.closeButton && (container = this._closeButton = create$1("a", "leaflet-popup-close-button", container), container.setAttribute("role", "button"), container.setAttribute("aria-label", "Close popup"), container.href = "#close", container.innerHTML = '\x3cspan aria-hidden\x3d"true"\x3e\x26#215;\x3c/span\x3e', on(container, "click", function(ev) {
        preventDefault(ev);
        this.close();
      }, this));
    }, _updateLayout:function() {
      var container = this._contentNode, style = container.style;
      style.width = "";
      style.whiteSpace = "nowrap";
      var width = container.offsetWidth;
      width = Math.min(width, this.options.maxWidth);
      width = Math.max(width, this.options.minWidth);
      style.width = width + 1 + "px";
      style.whiteSpace = "";
      style.height = "";
      width = container.offsetHeight;
      var maxHeight = this.options.maxHeight;
      maxHeight && width > maxHeight ? (style.height = maxHeight + "px", addClass(container, "leaflet-popup-scrolled")) : removeClass(container, "leaflet-popup-scrolled");
      this._containerWidth = this._container.offsetWidth;
    }, _animateZoom:function(e) {
      e = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);
      var anchor = this._getAnchor();
      setPosition(this._container, e.add(anchor));
    }, _adjustPan:function() {
      if (this.options.autoPan) {
        if (this._map._panAnim && this._map._panAnim.stop(), this._autopanning) {
          this._autopanning = !1;
        } else {
          var map = this._map, marginBottom = parseInt(getStyle(this._container, "marginBottom"), 10) || 0;
          marginBottom = this._container.offsetHeight + marginBottom;
          var containerWidth = this._containerWidth, layerPos = new Point(this._containerLeft, -marginBottom - this._containerBottom);
          layerPos._add(getPosition(this._container));
          layerPos = map.layerPointToContainerPoint(layerPos);
          var padding = toPoint(this.options.autoPanPadding), paddingTL = toPoint(this.options.autoPanPaddingTopLeft || padding);
          padding = toPoint(this.options.autoPanPaddingBottomRight || padding);
          var size = map.getSize(), dx = 0, dy = 0;
          layerPos.x + containerWidth + padding.x > size.x && (dx = layerPos.x + containerWidth - size.x + padding.x);
          layerPos.x - dx - paddingTL.x < 0 && (dx = layerPos.x - paddingTL.x);
          layerPos.y + marginBottom + padding.y > size.y && (dy = layerPos.y + marginBottom - size.y + padding.y);
          layerPos.y - dy - paddingTL.y < 0 && (dy = layerPos.y - paddingTL.y);
          if (dx || dy) {
            this.options.keepInView && (this._autopanning = !0), map.fire("autopanstart").panBy([dx, dy]);
          }
        }
      }
    }, _getAnchor:function() {
      return toPoint(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
    }});
    Map.mergeOptions({closePopupOnClick:!0});
    Map.include({openPopup:function(popup, latlng, options) {
      this._initOverlay(Popup, popup, latlng, options).openOn(this);
      return this;
    }, closePopup:function(popup) {
      (popup = arguments.length ? popup : this._popup) && popup.close();
      return this;
    }});
    Layer.include({bindPopup:function(content, options) {
      this._popup = this._initOverlay(Popup, this._popup, content, options);
      this._popupHandlersAdded || (this.on({click:this._openPopup, keypress:this._onKeyPress, remove:this.closePopup, move:this._movePopup}), this._popupHandlersAdded = !0);
      return this;
    }, unbindPopup:function() {
      this._popup && (this.off({click:this._openPopup, keypress:this._onKeyPress, remove:this.closePopup, move:this._movePopup}), this._popupHandlersAdded = !1, this._popup = null);
      return this;
    }, openPopup:function(latlng) {
      this._popup && (this instanceof FeatureGroup || (this._popup._source = this), this._popup._prepareOpen(latlng || this._latlng) && this._popup.openOn(this._map));
      return this;
    }, closePopup:function() {
      this._popup && this._popup.close();
      return this;
    }, togglePopup:function() {
      this._popup && this._popup.toggle(this);
      return this;
    }, isPopupOpen:function() {
      return this._popup ? this._popup.isOpen() : !1;
    }, setPopupContent:function(content) {
      this._popup && this._popup.setContent(content);
      return this;
    }, getPopup:function() {
      return this._popup;
    }, _openPopup:function(e) {
      if (this._popup && this._map) {
        stop(e);
        var target = e.layer || e.target;
        this._popup._source !== target || target instanceof Path ? (this._popup._source = target, this.openPopup(e.latlng)) : this._map.hasLayer(this._popup) ? this.closePopup() : this.openPopup(e.latlng);
      }
    }, _movePopup:function(e) {
      this._popup.setLatLng(e.latlng);
    }, _onKeyPress:function(e) {
      e.originalEvent.keyCode === 13 && this._openPopup(e);
    }});
    var Tooltip = DivOverlay.extend({options:{pane:"tooltipPane", offset:[0, 0], direction:"auto", permanent:!1, sticky:!1, opacity:0.9}, onAdd:function(map) {
      DivOverlay.prototype.onAdd.call(this, map);
      this.setOpacity(this.options.opacity);
      map.fire("tooltipopen", {tooltip:this});
      this._source && (this.addEventParent(this._source), this._source.fire("tooltipopen", {tooltip:this}, !0));
    }, onRemove:function(map) {
      DivOverlay.prototype.onRemove.call(this, map);
      map.fire("tooltipclose", {tooltip:this});
      this._source && (this.removeEventParent(this._source), this._source.fire("tooltipclose", {tooltip:this}, !0));
    }, getEvents:function() {
      var events = DivOverlay.prototype.getEvents.call(this);
      this.options.permanent || (events.preclick = this.close);
      return events;
    }, _initLayout:function() {
      this._contentNode = this._container = create$1("div", "leaflet-tooltip " + (this.options.className || "") + " leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide"));
      this._container.setAttribute("role", "tooltip");
      this._container.setAttribute("id", "leaflet-tooltip-" + stamp(this));
    }, _updateLayout:function() {
    }, _adjustPan:function() {
    }, _setPosition:function(pos) {
      var map = this._map, container = this._container;
      var subX = map.latLngToContainerPoint(map.getCenter());
      var tooltipPoint = map.layerPointToContainerPoint(pos);
      map = this.options.direction;
      var tooltipWidth = container.offsetWidth;
      var subY = container.offsetHeight;
      var offset = toPoint(this.options.offset), anchor = this._getAnchor();
      map === "top" ? subX = tooltipWidth / 2 : map === "bottom" ? (subX = tooltipWidth / 2, subY = 0) : (map === "center" ? subX = tooltipWidth / 2 : map === "right" ? subX = 0 : map === "left" ? subX = tooltipWidth : tooltipPoint.x < subX.x ? (map = "right", subX = 0) : (map = "left", subX = tooltipWidth + (offset.x + anchor.x) * 2), subY /= 2);
      pos = pos.subtract(toPoint(subX, subY, !0)).add(offset).add(anchor);
      removeClass(container, "leaflet-tooltip-right");
      removeClass(container, "leaflet-tooltip-left");
      removeClass(container, "leaflet-tooltip-top");
      removeClass(container, "leaflet-tooltip-bottom");
      addClass(container, "leaflet-tooltip-" + map);
      setPosition(container, pos);
    }, _updatePosition:function() {
      var pos = this._map.latLngToLayerPoint(this._latlng);
      this._setPosition(pos);
    }, setOpacity:function(opacity) {
      this.options.opacity = opacity;
      this._container && setOpacity(this._container, opacity);
    }, _animateZoom:function(e) {
      e = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);
      this._setPosition(e);
    }, _getAnchor:function() {
      return toPoint(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
    }});
    Map.include({openTooltip:function(tooltip, latlng, options) {
      this._initOverlay(Tooltip, tooltip, latlng, options).openOn(this);
      return this;
    }, closeTooltip:function(tooltip) {
      tooltip.close();
      return this;
    }});
    Layer.include({bindTooltip:function(content, options) {
      this._tooltip && this.isTooltipOpen() && this.unbindTooltip();
      this._tooltip = this._initOverlay(Tooltip, this._tooltip, content, options);
      this._initTooltipInteractions();
      this._tooltip.options.permanent && this._map && this._map.hasLayer(this) && this.openTooltip();
      return this;
    }, unbindTooltip:function() {
      this._tooltip && (this._initTooltipInteractions(!0), this.closeTooltip(), this._tooltip = null);
      return this;
    }, _initTooltipInteractions:function(remove) {
      if (remove || !this._tooltipHandlersAdded) {
        var onOff = remove ? "off" : "on", events = {remove:this.closeTooltip, move:this._moveTooltip};
        this._tooltip.options.permanent ? events.add = this._openTooltip : (events.mouseover = this._openTooltip, events.mouseout = this.closeTooltip, events.click = this._openTooltip, this._map ? this._addFocusListeners() : events.add = this._addFocusListeners);
        this._tooltip.options.sticky && (events.mousemove = this._moveTooltip);
        this[onOff](events);
        this._tooltipHandlersAdded = !remove;
      }
    }, openTooltip:function(latlng) {
      this._tooltip && (this instanceof FeatureGroup || (this._tooltip._source = this), this._tooltip._prepareOpen(latlng) && (this._tooltip.openOn(this._map), this.getElement ? this._setAriaDescribedByOnLayer(this) : this.eachLayer && this.eachLayer(this._setAriaDescribedByOnLayer, this)));
      return this;
    }, closeTooltip:function() {
      if (this._tooltip) {
        return this._tooltip.close();
      }
    }, toggleTooltip:function() {
      this._tooltip && this._tooltip.toggle(this);
      return this;
    }, isTooltipOpen:function() {
      return this._tooltip.isOpen();
    }, setTooltipContent:function(content) {
      this._tooltip && this._tooltip.setContent(content);
      return this;
    }, getTooltip:function() {
      return this._tooltip;
    }, _addFocusListeners:function() {
      this.getElement ? this._addFocusListenersOnLayer(this) : this.eachLayer && this.eachLayer(this._addFocusListenersOnLayer, this);
    }, _addFocusListenersOnLayer:function(layer) {
      var el = typeof layer.getElement === "function" && layer.getElement();
      el && (on(el, "focus", function() {
        this._tooltip._source = layer;
        this.openTooltip();
      }, this), on(el, "blur", this.closeTooltip, this));
    }, _setAriaDescribedByOnLayer:function(layer) {
      (layer = typeof layer.getElement === "function" && layer.getElement()) && layer.setAttribute("aria-describedby", this._tooltip._container.id);
    }, _openTooltip:function(e) {
      if (this._tooltip && this._map) {
        if (this._map.dragging && this._map.dragging.moving() && !this._openOnceFlag) {
          this._openOnceFlag = !0;
          var that = this;
          this._map.once("moveend", function() {
            that._openOnceFlag = !1;
            that._openTooltip(e);
          });
        } else {
          this._tooltip._source = e.layer || e.target, this.openTooltip(this._tooltip.options.sticky ? e.latlng : void 0);
        }
      }
    }, _moveTooltip:function(e) {
      var latlng = e.latlng;
      this._tooltip.options.sticky && e.originalEvent && (e = this._map.mouseEventToContainerPoint(e.originalEvent), e = this._map.containerPointToLayerPoint(e), latlng = this._map.layerPointToLatLng(e));
      this._tooltip.setLatLng(latlng);
    }});
    var DivIcon = Icon.extend({options:{iconSize:[12, 12], html:!1, bgPos:null, className:"leaflet-div-icon"}, createIcon:function(oldIcon) {
      oldIcon = oldIcon && oldIcon.tagName === "DIV" ? oldIcon : document.createElement("div");
      var options = this.options;
      options.html instanceof Element ? (empty(oldIcon), oldIcon.appendChild(options.html)) : oldIcon.innerHTML = options.html !== !1 ? options.html : "";
      options.bgPos && (options = toPoint(options.bgPos), oldIcon.style.backgroundPosition = -options.x + "px " + -options.y + "px");
      this._setIconStyles(oldIcon, "icon");
      return oldIcon;
    }, createShadow:function() {
      return null;
    }});
    Icon.Default = IconDefault;
    var GridLayer = Layer.extend({options:{tileSize:256, opacity:1, updateWhenIdle:Browser.mobile, updateWhenZooming:!0, updateInterval:200, zIndex:1, bounds:null, minZoom:0, maxZoom:void 0, maxNativeZoom:void 0, minNativeZoom:void 0, noWrap:!1, pane:"tilePane", className:"", keepBuffer:2}, initialize:function(options) {
      setOptions(this, options);
    }, onAdd:function() {
      this._initContainer();
      this._levels = {};
      this._tiles = {};
      this._resetView();
    }, beforeAdd:function(map) {
      map._addZoomLimit(this);
    }, onRemove:function(map) {
      this._removeAllTiles();
      remove(this._container);
      map._removeZoomLimit(this);
      this._container = null;
      this._tileZoom = void 0;
    }, bringToFront:function() {
      this._map && (toFront(this._container), this._setAutoZIndex(Math.max));
      return this;
    }, bringToBack:function() {
      this._map && (toBack(this._container), this._setAutoZIndex(Math.min));
      return this;
    }, getContainer:function() {
      return this._container;
    }, setOpacity:function(opacity) {
      this.options.opacity = opacity;
      this._updateOpacity();
      return this;
    }, setZIndex:function(zIndex) {
      this.options.zIndex = zIndex;
      this._updateZIndex();
      return this;
    }, isLoading:function() {
      return this._loading;
    }, redraw:function() {
      if (this._map) {
        this._removeAllTiles();
        var tileZoom = this._clampZoom(this._map.getZoom());
        tileZoom !== this._tileZoom && (this._tileZoom = tileZoom, this._updateLevels());
        this._update();
      }
      return this;
    }, getEvents:function() {
      var events = {viewprereset:this._invalidateAll, viewreset:this._resetView, zoom:this._resetView, moveend:this._onMoveEnd};
      this.options.updateWhenIdle || (this._onMove || (this._onMove = throttle(this._onMoveEnd, this.options.updateInterval, this)), events.move = this._onMove);
      this._zoomAnimated && (events.zoomanim = this._animateZoom);
      return events;
    }, createTile:function() {
      return document.createElement("div");
    }, getTileSize:function() {
      var s = this.options.tileSize;
      return s instanceof Point ? s : new Point(s, s);
    }, _updateZIndex:function() {
      this._container && this.options.zIndex !== void 0 && this.options.zIndex !== null && (this._container.style.zIndex = this.options.zIndex);
    }, _setAutoZIndex:function(compare) {
      for (var layers = this.getPane().children, edgeZIndex = -compare(-Infinity, Infinity), i = 0, len = layers.length, zIndex; i < len; i++) {
        zIndex = layers[i].style.zIndex, layers[i] !== this._container && zIndex && (edgeZIndex = compare(edgeZIndex, +zIndex));
      }
      isFinite(edgeZIndex) && (this.options.zIndex = edgeZIndex + compare(-1, 1), this._updateZIndex());
    }, _updateOpacity:function() {
      if (this._map && !Browser.ielt9) {
        setOpacity(this._container, this.options.opacity);
        var now = +new Date(), nextFrame = !1, willPrune = !1, key;
        for (key in this._tiles) {
          var tile = this._tiles[key];
          if (tile.current && tile.loaded) {
            var fade = Math.min(1, (now - tile.loaded) / 200);
            setOpacity(tile.el, fade);
            fade < 1 ? nextFrame = !0 : (tile.active ? willPrune = !0 : this._onOpaqueTile(tile), tile.active = !0);
          }
        }
        willPrune && !this._noPrune && this._pruneTiles();
        nextFrame && (cancelAnimFrame(this._fadeFrame), this._fadeFrame = requestAnimFrame(this._updateOpacity, this));
      }
    }, _onOpaqueTile:falseFn, _initContainer:function() {
      this._container || (this._container = create$1("div", "leaflet-layer " + (this.options.className || "")), this._updateZIndex(), this.options.opacity < 1 && this._updateOpacity(), this.getPane().appendChild(this._container));
    }, _updateLevels:function() {
      var zoom = this._tileZoom, maxZoom = this.options.maxZoom;
      if (zoom !== void 0) {
        for (var z in this._levels) {
          z = Number(z), this._levels[z].el.children.length || z === zoom ? (this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z), this._onUpdateLevel(z)) : (remove(this._levels[z].el), this._removeTilesAtZoom(z), this._onRemoveLevel(z), delete this._levels[z]);
        }
        z = this._levels[zoom];
        var map = this._map;
        z || (z = this._levels[zoom] = {}, z.el = create$1("div", "leaflet-tile-container leaflet-zoom-animated", this._container), z.el.style.zIndex = maxZoom, z.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round(), z.zoom = zoom, this._setZoomTransform(z, map.getCenter(), map.getZoom()), this._onCreateLevel(z));
        return this._level = z;
      }
    }, _onUpdateLevel:falseFn, _onRemoveLevel:falseFn, _onCreateLevel:falseFn, _pruneTiles:function() {
      if (this._map) {
        var key;
        var tile = this._map.getZoom();
        if (tile > this.options.maxZoom || tile < this.options.minZoom) {
          this._removeAllTiles();
        } else {
          for (key in this._tiles) {
            tile = this._tiles[key], tile.retain = tile.current;
          }
          for (key in this._tiles) {
            tile = this._tiles[key], tile.current && !tile.active && (tile = tile.coords, this._retainParent(tile.x, tile.y, tile.z, tile.z - 5) || this._retainChildren(tile.x, tile.y, tile.z, tile.z + 2));
          }
          for (key in this._tiles) {
            this._tiles[key].retain || this._removeTile(key);
          }
        }
      }
    }, _removeTilesAtZoom:function(zoom) {
      for (var key in this._tiles) {
        this._tiles[key].coords.z === zoom && this._removeTile(key);
      }
    }, _removeAllTiles:function() {
      for (var key in this._tiles) {
        this._removeTile(key);
      }
    }, _invalidateAll:function() {
      for (var z in this._levels) {
        remove(this._levels[z].el), this._onRemoveLevel(Number(z)), delete this._levels[z];
      }
      this._removeAllTiles();
      this._tileZoom = void 0;
    }, _retainParent:function(x, y, z, minZoom) {
      x = Math.floor(x / 2);
      y = Math.floor(y / 2);
      --z;
      var coords2 = new Point(+x, +y);
      coords2.z = +z;
      coords2 = this._tileCoordsToKey(coords2);
      if ((coords2 = this._tiles[coords2]) && coords2.active) {
        return coords2.retain = !0;
      }
      coords2 && coords2.loaded && (coords2.retain = !0);
      return z > minZoom ? this._retainParent(x, y, z, minZoom) : !1;
    }, _retainChildren:function(x, y, z, maxZoom) {
      for (var i = 2 * x; i < 2 * x + 2; i++) {
        for (var j = 2 * y; j < 2 * y + 2; j++) {
          var coords = new Point(i, j);
          coords.z = z + 1;
          coords = this._tileCoordsToKey(coords);
          (coords = this._tiles[coords]) && coords.active ? coords.retain = !0 : (coords && coords.loaded && (coords.retain = !0), z + 1 < maxZoom && this._retainChildren(i, j, z + 1, maxZoom));
        }
      }
    }, _resetView:function(e) {
      e = e && (e.pinch || e.flyTo);
      this._setView(this._map.getCenter(), this._map.getZoom(), e, e);
    }, _animateZoom:function(e) {
      this._setView(e.center, e.zoom, !0, e.noUpdate);
    }, _clampZoom:function(zoom) {
      var options = this.options;
      return void 0 !== options.minNativeZoom && zoom < options.minNativeZoom ? options.minNativeZoom : void 0 !== options.maxNativeZoom && options.maxNativeZoom < zoom ? options.maxNativeZoom : zoom;
    }, _setView:function(center, zoom, noPrune, noUpdate) {
      var tileZoom = Math.round(zoom);
      tileZoom = this.options.maxZoom !== void 0 && tileZoom > this.options.maxZoom || this.options.minZoom !== void 0 && tileZoom < this.options.minZoom ? void 0 : this._clampZoom(tileZoom);
      var tileZoomChanged = this.options.updateWhenZooming && tileZoom !== this._tileZoom;
      if (!noUpdate || tileZoomChanged) {
        this._tileZoom = tileZoom, this._abortLoading && this._abortLoading(), this._updateLevels(), this._resetGrid(), tileZoom !== void 0 && this._update(center), noPrune || this._pruneTiles(), this._noPrune = !!noPrune;
      }
      this._setZoomTransforms(center, zoom);
    }, _setZoomTransforms:function(center, zoom) {
      for (var i in this._levels) {
        this._setZoomTransform(this._levels[i], center, zoom);
      }
    }, _setZoomTransform:function(level, center, zoom) {
      var scale = this._map.getZoomScale(zoom, level.zoom);
      center = level.origin.multiplyBy(scale).subtract(this._map._getNewPixelOrigin(center, zoom)).round();
      Browser.any3d ? setTransform(level.el, center, scale) : setPosition(level.el, center);
    }, _resetGrid:function() {
      var map = this._map, crs = map.options.crs, tileSize = this._tileSize = this.getTileSize(), tileZoom = this._tileZoom, bounds = this._map.getPixelWorldBounds(this._tileZoom);
      bounds && (this._globalTileRange = this._pxBoundsToTileRange(bounds));
      this._wrapX = crs.wrapLng && !this.options.noWrap && [Math.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x), Math.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)];
      this._wrapY = crs.wrapLat && !this.options.noWrap && [Math.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x), Math.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)];
    }, _onMoveEnd:function() {
      this._map && !this._map._animatingZoom && this._update();
    }, _getTiledPixelBounds:function(center) {
      var map = this._map, mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom();
      mapZoom = map.getZoomScale(mapZoom, this._tileZoom);
      center = map.project(center, this._tileZoom).floor();
      map = map.getSize().divideBy(mapZoom * 2);
      return new Bounds(center.subtract(map), center.add(map));
    }, _update:function(center) {
      var map = this._map;
      if (map) {
        var zoom = this._clampZoom(map.getZoom());
        center === void 0 && (center = map.getCenter());
        if (this._tileZoom !== void 0) {
          map = this._getTiledPixelBounds(center);
          var tileRange = this._pxBoundsToTileRange(map), tileCenter = tileRange.getCenter();
          map = [];
          var margin = this.options.keepBuffer;
          margin = new Bounds(tileRange.getBottomLeft().subtract([margin, -margin]), tileRange.getTopRight().add([margin, -margin]));
          if (!(isFinite(tileRange.min.x) && isFinite(tileRange.min.y) && isFinite(tileRange.max.x) && isFinite(tileRange.max.y))) {
            throw Error("Attempted to load an infinite number of tiles");
          }
          for (var key in this._tiles) {
            var c = this._tiles[key].coords;
            c.z === this._tileZoom && margin.contains(new Point(c.x, c.y)) || (this._tiles[key].current = !1);
          }
          if (Math.abs(zoom - this._tileZoom) > 1) {
            this._setView(center, zoom);
          } else {
            for (zoom = tileRange.min.y; zoom <= tileRange.max.y; zoom++) {
              for (center = tileRange.min.x; center <= tileRange.max.x; center++) {
                key = new Point(center, zoom), key.z = this._tileZoom, this._isValidTile(key) && ((margin = this._tiles[this._tileCoordsToKey(key)]) ? margin.current = !0 : map.push(key));
              }
            }
            map.sort(function(a, b) {
              return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
            });
            if (map.length !== 0) {
              this._loading || (this._loading = !0, this.fire("loading"));
              tileRange = document.createDocumentFragment();
              for (center = 0; center < map.length; center++) {
                this._addTile(map[center], tileRange);
              }
              this._level.el.appendChild(tileRange);
            }
          }
        }
      }
    }, _isValidTile:function(coords) {
      var crs = this._map.options.crs;
      if (!crs.infinite) {
        var bounds = this._globalTileRange;
        if (!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x) || !crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y)) {
          return !1;
        }
      }
      if (!this.options.bounds) {
        return !0;
      }
      coords = this._tileCoordsToBounds(coords);
      return toLatLngBounds(this.options.bounds).overlaps(coords);
    }, _keyToBounds:function(key) {
      return this._tileCoordsToBounds(this._keyToTileCoords(key));
    }, _tileCoordsToNwSe:function(coords) {
      var map = this._map, tileSize = this.getTileSize(), nwPoint = coords.scaleBy(tileSize);
      tileSize = nwPoint.add(tileSize);
      nwPoint = map.unproject(nwPoint, coords.z);
      coords = map.unproject(tileSize, coords.z);
      return [nwPoint, coords];
    }, _tileCoordsToBounds:function(coords) {
      coords = this._tileCoordsToNwSe(coords);
      coords = new LatLngBounds(coords[0], coords[1]);
      this.options.noWrap || (coords = this._map.wrapLatLngBounds(coords));
      return coords;
    }, _tileCoordsToKey:function(coords) {
      return coords.x + ":" + coords.y + ":" + coords.z;
    }, _keyToTileCoords:function(key) {
      key = key.split(":");
      var coords = new Point(+key[0], +key[1]);
      coords.z = +key[2];
      return coords;
    }, _removeTile:function(key) {
      var tile = this._tiles[key];
      tile && (remove(tile.el), delete this._tiles[key], this.fire("tileunload", {tile:tile.el, coords:this._keyToTileCoords(key)}));
    }, _initTile:function(tile) {
      addClass(tile, "leaflet-tile");
      var tileSize = this.getTileSize();
      tile.style.width = tileSize.x + "px";
      tile.style.height = tileSize.y + "px";
      tile.onselectstart = falseFn;
      tile.onmousemove = falseFn;
      Browser.ielt9 && this.options.opacity < 1 && setOpacity(tile, this.options.opacity);
    }, _addTile:function(coords, container) {
      var tilePos = this._getTilePos(coords), key = this._tileCoordsToKey(coords), tile = this.createTile(this._wrapCoords(coords), bind(this._tileReady, this, coords));
      this._initTile(tile);
      this.createTile.length < 2 && requestAnimFrame(bind(this._tileReady, this, coords, null, tile));
      setPosition(tile, tilePos);
      this._tiles[key] = {el:tile, coords, current:!0};
      container.appendChild(tile);
      this.fire("tileloadstart", {tile, coords});
    }, _tileReady:function(coords, err, tile) {
      err && this.fire("tileerror", {error:err, tile, coords});
      tile = this._tileCoordsToKey(coords);
      if (tile = this._tiles[tile]) {
        tile.loaded = +new Date(), this._map._fadeAnimated ? (setOpacity(tile.el, 0), cancelAnimFrame(this._fadeFrame), this._fadeFrame = requestAnimFrame(this._updateOpacity, this)) : (tile.active = !0, this._pruneTiles()), err || (addClass(tile.el, "leaflet-tile-loaded"), this.fire("tileload", {tile:tile.el, coords})), this._noTilesToLoad() && (this._loading = !1, this.fire("load"), Browser.ielt9 || !this._map._fadeAnimated ? requestAnimFrame(this._pruneTiles, this) : setTimeout(bind(this._pruneTiles, 
        this), 250));
      }
    }, _getTilePos:function(coords) {
      return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);
    }, _wrapCoords:function(coords) {
      var newCoords = new Point(this._wrapX ? wrapNum(coords.x, this._wrapX) : coords.x, this._wrapY ? wrapNum(coords.y, this._wrapY) : coords.y);
      newCoords.z = coords.z;
      return newCoords;
    }, _pxBoundsToTileRange:function(bounds) {
      var tileSize = this.getTileSize();
      return new Bounds(bounds.min.unscaleBy(tileSize).floor(), bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1]));
    }, _noTilesToLoad:function() {
      for (var key in this._tiles) {
        if (!this._tiles[key].loaded) {
          return !1;
        }
      }
      return !0;
    }}), TileLayer = GridLayer.extend({options:{minZoom:0, maxZoom:18, subdomains:"abc", errorTileUrl:"", zoomOffset:0, tms:!1, zoomReverse:!1, detectRetina:!1, crossOrigin:!1, referrerPolicy:!1}, initialize:function(url, options) {
      this._url = url;
      options = setOptions(this, options);
      options.detectRetina && Browser.retina && options.maxZoom > 0 ? (options.tileSize = Math.floor(options.tileSize / 2), options.zoomReverse ? (options.zoomOffset--, options.minZoom = Math.min(options.maxZoom, options.minZoom + 1)) : (options.zoomOffset++, options.maxZoom = Math.max(options.minZoom, options.maxZoom - 1)), options.minZoom = Math.max(0, options.minZoom)) : options.zoomReverse ? options.minZoom = Math.min(options.maxZoom, options.minZoom) : options.maxZoom = Math.max(options.minZoom, 
      options.maxZoom);
      typeof options.subdomains === "string" && (options.subdomains = options.subdomains.split(""));
      this.on("tileunload", this._onTileRemove);
    }, setUrl:function(url, noRedraw) {
      this._url === url && noRedraw === void 0 && (noRedraw = !0);
      this._url = url;
      noRedraw || this.redraw();
      return this;
    }, createTile:function(coords, done) {
      var tile = document.createElement("img");
      on(tile, "load", bind(this._tileOnLoad, this, done, tile));
      on(tile, "error", bind(this._tileOnError, this, done, tile));
      if (this.options.crossOrigin || this.options.crossOrigin === "") {
        tile.crossOrigin = this.options.crossOrigin === !0 ? "" : this.options.crossOrigin;
      }
      typeof this.options.referrerPolicy === "string" && (tile.referrerPolicy = this.options.referrerPolicy);
      tile.alt = "";
      tile.src = this.getTileUrl(coords);
      return tile;
    }, getTileUrl:function(coords) {
      var data = {r:Browser.retina ? "@2x" : "", s:this._getSubdomain(coords), x:coords.x, y:coords.y, z:this._getZoomForUrl()};
      this._map && !this._map.options.crs.infinite && (coords = this._globalTileRange.max.y - coords.y, this.options.tms && (data.y = coords), data["-y"] = coords);
      return template(this._url, extend(data, this.options));
    }, _tileOnLoad:function(done, tile) {
      Browser.ielt9 ? setTimeout(bind(done, this, null, tile), 0) : done(null, tile);
    }, _tileOnError:function(done, tile, e) {
      var errorUrl = this.options.errorTileUrl;
      errorUrl && tile.getAttribute("src") !== errorUrl && (tile.src = errorUrl);
      done(e, tile);
    }, _onTileRemove:function(e) {
      e.tile.onload = null;
    }, _getZoomForUrl:function() {
      var zoom = this._tileZoom, maxZoom = this.options.maxZoom, zoomOffset = this.options.zoomOffset;
      this.options.zoomReverse && (zoom = maxZoom - zoom);
      return zoom + zoomOffset;
    }, _getSubdomain:function(tilePoint) {
      return this.options.subdomains[Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length];
    }, _abortLoading:function() {
      var i;
      for (i in this._tiles) {
        if (this._tiles[i].coords.z !== this._tileZoom) {
          var tile = this._tiles[i].el;
          tile.onload = falseFn;
          tile.onerror = falseFn;
          if (!tile.complete) {
            tile.src = "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs\x3d";
            var coords = this._tiles[i].coords;
            remove(tile);
            delete this._tiles[i];
            this.fire("tileabort", {tile, coords});
          }
        }
      }
    }, _removeTile:function(key) {
      var tile = this._tiles[key];
      if (tile) {
        return tile.el.setAttribute("src", "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs\x3d"), GridLayer.prototype._removeTile.call(this, key);
      }
    }, _tileReady:function(coords, err, tile) {
      if (this._map && (!tile || tile.getAttribute("src") !== "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs\x3d")) {
        return GridLayer.prototype._tileReady.call(this, coords, err, tile);
      }
    }}), TileLayerWMS = TileLayer.extend({defaultWmsParams:{service:"WMS", request:"GetMap", layers:"", styles:"", format:"image/jpeg", transparent:!1, version:"1.1.1"}, options:{crs:null, uppercase:!1}, initialize:function(url, options) {
      this._url = url;
      url = extend({}, this.defaultWmsParams);
      for (var i in options) {
        i in this.options || (url[i] = options[i]);
      }
      options = setOptions(this, options);
      options = options.detectRetina && Browser.retina ? 2 : 1;
      i = this.getTileSize();
      url.width = i.x * options;
      url.height = i.y * options;
      this.wmsParams = url;
    }, onAdd:function(map) {
      this._crs = this.options.crs || map.options.crs;
      this._wmsVersion = parseFloat(this.wmsParams.version);
      this.wmsParams[this._wmsVersion >= 1.3 ? "crs" : "srs"] = this._crs.code;
      TileLayer.prototype.onAdd.call(this, map);
    }, getTileUrl:function(coords) {
      var tileBounds = this._tileCoordsToNwSe(coords), crs = this._crs;
      crs = toBounds(crs.project(tileBounds[0]), crs.project(tileBounds[1]));
      tileBounds = crs.min;
      crs = crs.max;
      tileBounds = (this._wmsVersion >= 1.3 && this._crs === EPSG4326 ? [tileBounds.y, tileBounds.x, crs.y, crs.x] : [tileBounds.x, tileBounds.y, crs.x, crs.y]).join(",");
      coords = TileLayer.prototype.getTileUrl.call(this, coords);
      return coords + getParamString(this.wmsParams, coords, this.options.uppercase) + (this.options.uppercase ? "\x26BBOX\x3d" : "\x26bbox\x3d") + tileBounds;
    }, setParams:function(params, noRedraw) {
      extend(this.wmsParams, params);
      noRedraw || this.redraw();
      return this;
    }});
    TileLayer.WMS = TileLayerWMS;
    tileLayer.wms = function(url, options) {
      return new TileLayerWMS(url, options);
    };
    var Renderer = Layer.extend({options:{padding:0.1}, initialize:function(options) {
      setOptions(this, options);
      stamp(this);
      this._layers = this._layers || {};
    }, onAdd:function() {
      this._container || (this._initContainer(), addClass(this._container, "leaflet-zoom-animated"));
      this.getPane().appendChild(this._container);
      this._update();
      this.on("update", this._updatePaths, this);
    }, onRemove:function() {
      this.off("update", this._updatePaths, this);
      this._destroyContainer();
    }, getEvents:function() {
      var events = {viewreset:this._reset, zoom:this._onZoom, moveend:this._update, zoomend:this._onZoomEnd};
      this._zoomAnimated && (events.zoomanim = this._onAnimZoom);
      return events;
    }, _onAnimZoom:function(ev) {
      this._updateTransform(ev.center, ev.zoom);
    }, _onZoom:function() {
      this._updateTransform(this._map.getCenter(), this._map.getZoom());
    }, _updateTransform:function(center, zoom) {
      var scale = this._map.getZoomScale(zoom, this._zoom), viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding), currentCenterPoint = this._map.project(this._center, zoom);
      center = viewHalf.multiplyBy(-scale).add(currentCenterPoint).subtract(this._map._getNewPixelOrigin(center, zoom));
      Browser.any3d ? setTransform(this._container, center, scale) : setPosition(this._container, center);
    }, _reset:function() {
      this._update();
      this._updateTransform(this._center, this._zoom);
      for (var id in this._layers) {
        this._layers[id]._reset();
      }
    }, _onZoomEnd:function() {
      for (var id in this._layers) {
        this._layers[id]._project();
      }
    }, _updatePaths:function() {
      for (var id in this._layers) {
        this._layers[id]._update();
      }
    }, _update:function() {
      var p = this.options.padding, size = this._map.getSize(), min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();
      this._bounds = new Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());
      this._center = this._map.getCenter();
      this._zoom = this._map.getZoom();
    }}), Canvas = Renderer.extend({options:{tolerance:0}, getEvents:function() {
      var events = Renderer.prototype.getEvents.call(this);
      events.viewprereset = this._onViewPreReset;
      return events;
    }, _onViewPreReset:function() {
      this._postponeUpdatePaths = !0;
    }, onAdd:function() {
      Renderer.prototype.onAdd.call(this);
      this._draw();
    }, _initContainer:function() {
      var container = this._container = document.createElement("canvas");
      on(container, "mousemove", this._onMouseMove, this);
      on(container, "click dblclick mousedown mouseup contextmenu", this._onClick, this);
      on(container, "mouseout", this._handleMouseOut, this);
      container._leaflet_disable_events = !0;
      this._ctx = container.getContext("2d");
    }, _destroyContainer:function() {
      cancelAnimFrame(this._redrawRequest);
      delete this._ctx;
      remove(this._container);
      off(this._container);
      delete this._container;
    }, _updatePaths:function() {
      if (!this._postponeUpdatePaths) {
        this._redrawBounds = null;
        for (var id in this._layers) {
          var layer = this._layers[id];
          layer._update();
        }
        this._redraw();
      }
    }, _update:function() {
      if (!this._map._animatingZoom || !this._bounds) {
        Renderer.prototype._update.call(this);
        var b = this._bounds, container = this._container, size = b.getSize(), m = Browser.retina ? 2 : 1;
        setPosition(container, b.min);
        container.width = m * size.x;
        container.height = m * size.y;
        container.style.width = size.x + "px";
        container.style.height = size.y + "px";
        Browser.retina && this._ctx.scale(2, 2);
        this._ctx.translate(-b.min.x, -b.min.y);
        this.fire("update");
      }
    }, _reset:function() {
      Renderer.prototype._reset.call(this);
      this._postponeUpdatePaths && (this._postponeUpdatePaths = !1, this._updatePaths());
    }, _initPath:function(layer) {
      this._updateDashArray(layer);
      this._layers[stamp(layer)] = layer;
      layer = layer._order = {layer, prev:this._drawLast, next:null};
      this._drawLast && (this._drawLast.next = layer);
      this._drawLast = layer;
      this._drawFirst = this._drawFirst || this._drawLast;
    }, _addPath:function(layer) {
      this._requestRedraw(layer);
    }, _removePath:function(layer) {
      var order = layer._order, next = order.next;
      order = order.prev;
      next ? next.prev = order : this._drawLast = order;
      order ? order.next = next : this._drawFirst = next;
      delete layer._order;
      delete this._layers[stamp(layer)];
      this._requestRedraw(layer);
    }, _updatePath:function(layer) {
      this._extendRedrawBounds(layer);
      layer._project();
      layer._update();
      this._requestRedraw(layer);
    }, _updateStyle:function(layer) {
      this._updateDashArray(layer);
      this._requestRedraw(layer);
    }, _updateDashArray:function(layer) {
      if (typeof layer.options.dashArray === "string") {
        var parts = layer.options.dashArray.split(/[, ]+/), dashArray = [], i;
        for (i = 0; i < parts.length; i++) {
          var dashValue = Number(parts[i]);
          if (isNaN(dashValue)) {
            return;
          }
          dashArray.push(dashValue);
        }
        layer.options._dashArray = dashArray;
      } else {
        layer.options._dashArray = layer.options.dashArray;
      }
    }, _requestRedraw:function(layer) {
      this._map && (this._extendRedrawBounds(layer), this._redrawRequest = this._redrawRequest || requestAnimFrame(this._redraw, this));
    }, _extendRedrawBounds:function(layer) {
      if (layer._pxBounds) {
        var padding = (layer.options.weight || 0) + 1;
        this._redrawBounds = this._redrawBounds || new Bounds();
        this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));
        this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));
      }
    }, _redraw:function() {
      this._redrawRequest = null;
      this._redrawBounds && (this._redrawBounds.min._floor(), this._redrawBounds.max._ceil());
      this._clear();
      this._draw();
      this._redrawBounds = null;
    }, _clear:function() {
      var bounds = this._redrawBounds;
      if (bounds) {
        var size = bounds.getSize();
        this._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);
      } else {
        this._ctx.save(), this._ctx.setTransform(1, 0, 0, 1, 0, 0), this._ctx.clearRect(0, 0, this._container.width, this._container.height), this._ctx.restore();
      }
    }, _draw:function() {
      var bounds = this._redrawBounds;
      this._ctx.save();
      if (bounds) {
        var layer = bounds.getSize();
        this._ctx.beginPath();
        this._ctx.rect(bounds.min.x, bounds.min.y, layer.x, layer.y);
        this._ctx.clip();
      }
      this._drawing = !0;
      for (var order = this._drawFirst; order; order = order.next) {
        layer = order.layer, (!bounds || layer._pxBounds && layer._pxBounds.intersects(bounds)) && layer._updatePath();
      }
      this._drawing = !1;
      this._ctx.restore();
    }, _updatePoly:function(layer, closed) {
      if (this._drawing) {
        var i, len2, parts = layer._parts, len = parts.length, ctx = this._ctx;
        if (len) {
          ctx.beginPath();
          for (i = 0; i < len; i++) {
            var j = 0;
            for (len2 = parts[i].length; j < len2; j++) {
              var p = parts[i][j];
              ctx[j ? "lineTo" : "moveTo"](p.x, p.y);
            }
            closed && ctx.closePath();
          }
          this._fillStroke(ctx, layer);
        }
      }
    }, _updateCircle:function(layer) {
      if (this._drawing && !layer._empty()) {
        var p = layer._point, ctx = this._ctx, r = Math.max(Math.round(layer._radius), 1), s = (Math.max(Math.round(layer._radiusY), 1) || r) / r;
        s !== 1 && (ctx.save(), ctx.scale(1, s));
        ctx.beginPath();
        ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, !1);
        s !== 1 && ctx.restore();
        this._fillStroke(ctx, layer);
      }
    }, _fillStroke:function(ctx, layer) {
      var options = layer.options;
      options.fill && (ctx.globalAlpha = options.fillOpacity, ctx.fillStyle = options.fillColor || options.color, ctx.fill(options.fillRule || "evenodd"));
      options.stroke && options.weight !== 0 && (ctx.setLineDash && ctx.setLineDash(layer.options && layer.options._dashArray || []), ctx.globalAlpha = options.opacity, ctx.lineWidth = options.weight, ctx.strokeStyle = options.color, ctx.lineCap = options.lineCap, ctx.lineJoin = options.lineJoin, ctx.stroke());
    }, _onClick:function(e) {
      for (var point = this._map.mouseEventToLayerPoint(e), layer, clickedLayer, order = this._drawFirst; order; order = order.next) {
        layer = order.layer, layer.options.interactive && layer._containsPoint(point) && (e.type !== "click" && e.type !== "preclick" || !this._map._draggableMoved(layer)) && (clickedLayer = layer);
      }
      this._fireEvent(clickedLayer ? [clickedLayer] : !1, e);
    }, _onMouseMove:function(e) {
      if (this._map && !this._map.dragging.moving() && !this._map._animatingZoom) {
        var point = this._map.mouseEventToLayerPoint(e);
        this._handleMouseHover(e, point);
      }
    }, _handleMouseOut:function(e) {
      var layer = this._hoveredLayer;
      layer && (removeClass(this._container, "leaflet-interactive"), this._fireEvent([layer], e, "mouseout"), this._hoveredLayer = null, this._mouseHoverThrottled = !1);
    }, _handleMouseHover:function(e, point) {
      if (!this._mouseHoverThrottled) {
        for (var layer, candidateHoveredLayer, order = this._drawFirst; order; order = order.next) {
          layer = order.layer, layer.options.interactive && layer._containsPoint(point) && (candidateHoveredLayer = layer);
        }
        candidateHoveredLayer !== this._hoveredLayer && (this._handleMouseOut(e), candidateHoveredLayer && (addClass(this._container, "leaflet-interactive"), this._fireEvent([candidateHoveredLayer], e, "mouseover"), this._hoveredLayer = candidateHoveredLayer));
        this._fireEvent(this._hoveredLayer ? [this._hoveredLayer] : !1, e);
        this._mouseHoverThrottled = !0;
        setTimeout(bind(function() {
          this._mouseHoverThrottled = !1;
        }, this), 32);
      }
    }, _fireEvent:function(layers, e, type) {
      this._map._fireDOMEvent(e, type || e.type, layers);
    }, _bringToFront:function(layer) {
      var order = layer._order;
      if (order) {
        var next = order.next, prev = order.prev;
        next && ((next.prev = prev) ? prev.next = next : next && (this._drawFirst = next), order.prev = this._drawLast, this._drawLast.next = order, order.next = null, this._drawLast = order, this._requestRedraw(layer));
      }
    }, _bringToBack:function(layer) {
      var order = layer._order;
      if (order) {
        var next = order.next, prev = order.prev;
        prev && ((prev.next = next) ? next.prev = prev : prev && (this._drawLast = prev), order.prev = null, order.next = this._drawFirst, this._drawFirst = this._drawFirst.prev = order, this._requestRedraw(layer));
      }
    }}), vmlCreate = function() {
      try {
        return document.namespaces.add("lvml", "urn:schemas-microsoft-com:vml"), function(name) {
          return document.createElement("\x3clvml:" + name + ' class\x3d"lvml"\x3e');
        };
      } catch (e) {
      }
      return function(name) {
        return document.createElement("\x3c" + name + ' xmlns\x3d"urn:schemas-microsoft.com:vml" class\x3d"lvml"\x3e');
      };
    }(), vmlMixin = {_initContainer:function() {
      this._container = create$1("div", "leaflet-vml-container");
    }, _update:function() {
      this._map._animatingZoom || (Renderer.prototype._update.call(this), this.fire("update"));
    }, _initPath:function(layer) {
      var container = layer._container = vmlCreate("shape");
      addClass(container, "leaflet-vml-shape " + (this.options.className || ""));
      container.coordsize = "1 1";
      layer._path = vmlCreate("path");
      container.appendChild(layer._path);
      this._updateStyle(layer);
      this._layers[stamp(layer)] = layer;
    }, _addPath:function(layer) {
      var container = layer._container;
      this._container.appendChild(container);
      layer.options.interactive && layer.addInteractiveTarget(container);
    }, _removePath:function(layer) {
      var container = layer._container;
      remove(container);
      layer.removeInteractiveTarget(container);
      delete this._layers[stamp(layer)];
    }, _updateStyle:function(layer) {
      var stroke = layer._stroke, fill = layer._fill, options = layer.options, container = layer._container;
      container.stroked = !!options.stroke;
      container.filled = !!options.fill;
      options.stroke ? (stroke || (stroke = layer._stroke = vmlCreate("stroke")), container.appendChild(stroke), stroke.weight = options.weight + "px", stroke.color = options.color, stroke.opacity = options.opacity, stroke.dashStyle = options.dashArray ? isArray(options.dashArray) ? options.dashArray.join(" ") : options.dashArray.replace(/( *, *)/g, " ") : "", stroke.endcap = options.lineCap.replace("butt", "flat"), stroke.joinstyle = options.lineJoin) : stroke && (container.removeChild(stroke), 
      layer._stroke = null);
      options.fill ? (fill || (fill = layer._fill = vmlCreate("fill")), container.appendChild(fill), fill.color = options.fillColor || options.color, fill.opacity = options.fillOpacity) : fill && (container.removeChild(fill), layer._fill = null);
    }, _updateCircle:function(layer) {
      var p = layer._point.round(), r = Math.round(layer._radius), r2 = Math.round(layer._radiusY || r);
      this._setPath(layer, layer._empty() ? "M0 0" : "AL " + p.x + "," + p.y + " " + r + "," + r2 + " 0,23592600");
    }, _setPath:function(layer, path) {
      layer._path.v = path;
    }, _bringToFront:function(layer) {
      toFront(layer._container);
    }, _bringToBack:function(layer) {
      toBack(layer._container);
    }}, create = Browser.vml ? vmlCreate : svgCreate, SVG = Renderer.extend({_initContainer:function() {
      this._container = create("svg");
      this._container.setAttribute("pointer-events", "none");
      this._rootGroup = create("g");
      this._container.appendChild(this._rootGroup);
    }, _destroyContainer:function() {
      remove(this._container);
      off(this._container);
      delete this._container;
      delete this._rootGroup;
      delete this._svgSize;
    }, _update:function() {
      if (!this._map._animatingZoom || !this._bounds) {
        Renderer.prototype._update.call(this);
        var b = this._bounds, size = b.getSize(), container = this._container;
        this._svgSize && this._svgSize.equals(size) || (this._svgSize = size, container.setAttribute("width", size.x), container.setAttribute("height", size.y));
        setPosition(container, b.min);
        container.setAttribute("viewBox", [b.min.x, b.min.y, size.x, size.y].join(" "));
        this.fire("update");
      }
    }, _initPath:function(layer) {
      var path = layer._path = create("path");
      layer.options.className && addClass(path, layer.options.className);
      layer.options.interactive && addClass(path, "leaflet-interactive");
      this._updateStyle(layer);
      this._layers[stamp(layer)] = layer;
    }, _addPath:function(layer) {
      this._rootGroup || this._initContainer();
      this._rootGroup.appendChild(layer._path);
      layer.addInteractiveTarget(layer._path);
    }, _removePath:function(layer) {
      remove(layer._path);
      layer.removeInteractiveTarget(layer._path);
      delete this._layers[stamp(layer)];
    }, _updatePath:function(layer) {
      layer._project();
      layer._update();
    }, _updateStyle:function(layer) {
      var path = layer._path;
      layer = layer.options;
      path && (layer.stroke ? (path.setAttribute("stroke", layer.color), path.setAttribute("stroke-opacity", layer.opacity), path.setAttribute("stroke-width", layer.weight), path.setAttribute("stroke-linecap", layer.lineCap), path.setAttribute("stroke-linejoin", layer.lineJoin), layer.dashArray ? path.setAttribute("stroke-dasharray", layer.dashArray) : path.removeAttribute("stroke-dasharray"), layer.dashOffset ? path.setAttribute("stroke-dashoffset", layer.dashOffset) : path.removeAttribute("stroke-dashoffset")) : 
      path.setAttribute("stroke", "none"), layer.fill ? (path.setAttribute("fill", layer.fillColor || layer.color), path.setAttribute("fill-opacity", layer.fillOpacity), path.setAttribute("fill-rule", layer.fillRule || "evenodd")) : path.setAttribute("fill", "none"));
    }, _updatePoly:function(layer, closed) {
      this._setPath(layer, pointsToPath(layer._parts, closed));
    }, _updateCircle:function(layer) {
      var p = layer._point, r = Math.max(Math.round(layer._radius), 1), arc = "a" + r + "," + (Math.max(Math.round(layer._radiusY), 1) || r) + " 0 1,0 ";
      p = layer._empty() ? "M0 0" : "M" + (p.x - r) + "," + p.y + arc + r * 2 + ",0 " + arc + -r * 2 + ",0 ";
      this._setPath(layer, p);
    }, _setPath:function(layer, path) {
      layer._path.setAttribute("d", path);
    }, _bringToFront:function(layer) {
      toFront(layer._path);
    }, _bringToBack:function(layer) {
      toBack(layer._path);
    }});
    Browser.vml && SVG.include(vmlMixin);
    Map.include({getRenderer:function(layer) {
      layer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;
      layer || (layer = this._renderer = this._createRenderer());
      this.hasLayer(layer) || this.addLayer(layer);
      return layer;
    }, _getPaneRenderer:function(name) {
      if (name === "overlayPane" || name === void 0) {
        return !1;
      }
      var renderer = this._paneRenderers[name];
      renderer === void 0 && (renderer = this._createRenderer({pane:name}), this._paneRenderers[name] = renderer);
      return renderer;
    }, _createRenderer:function(options) {
      return this.options.preferCanvas && canvas(options) || svg(options);
    }});
    var Rectangle = Polygon.extend({initialize:function(latLngBounds, options) {
      Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
    }, setBounds:function(latLngBounds) {
      return this.setLatLngs(this._boundsToLatLngs(latLngBounds));
    }, _boundsToLatLngs:function(latLngBounds) {
      latLngBounds = toLatLngBounds(latLngBounds);
      return [latLngBounds.getSouthWest(), latLngBounds.getNorthWest(), latLngBounds.getNorthEast(), latLngBounds.getSouthEast()];
    }});
    SVG.create = create;
    SVG.pointsToPath = pointsToPath;
    GeoJSON.geometryToLayer = geometryToLayer;
    GeoJSON.coordsToLatLng = coordsToLatLng;
    GeoJSON.coordsToLatLngs = coordsToLatLngs;
    GeoJSON.latLngToCoords = latLngToCoords;
    GeoJSON.latLngsToCoords = latLngsToCoords;
    GeoJSON.getFeature = getFeature;
    GeoJSON.asFeature = asFeature;
    Map.mergeOptions({boxZoom:!0});
    var BoxZoom = Handler.extend({initialize:function(map) {
      this._map = map;
      this._container = map._container;
      this._pane = map._panes.overlayPane;
      this._resetStateTimeout = 0;
      map.on("unload", this._destroy, this);
    }, addHooks:function() {
      on(this._container, "mousedown", this._onMouseDown, this);
    }, removeHooks:function() {
      off(this._container, "mousedown", this._onMouseDown, this);
    }, moved:function() {
      return this._moved;
    }, _destroy:function() {
      remove(this._pane);
      delete this._pane;
    }, _resetState:function() {
      this._resetStateTimeout = 0;
      this._moved = !1;
    }, _clearDeferredResetState:function() {
      this._resetStateTimeout !== 0 && (clearTimeout(this._resetStateTimeout), this._resetStateTimeout = 0);
    }, _onMouseDown:function(e) {
      if (!e.shiftKey || e.which !== 1 && e.button !== 1) {
        return !1;
      }
      this._clearDeferredResetState();
      this._resetState();
      disableTextSelection();
      disableImageDrag();
      this._startPoint = this._map.mouseEventToContainerPoint(e);
      on(document, {contextmenu:stop, mousemove:this._onMouseMove, mouseup:this._onMouseUp, keydown:this._onKeyDown}, this);
    }, _onMouseMove:function(e) {
      this._moved || (this._moved = !0, this._box = create$1("div", "leaflet-zoom-box", this._container), addClass(this._container, "leaflet-crosshair"), this._map.fire("boxzoomstart"));
      this._point = this._map.mouseEventToContainerPoint(e);
      e = new Bounds(this._point, this._startPoint);
      var size = e.getSize();
      setPosition(this._box, e.min);
      this._box.style.width = size.x + "px";
      this._box.style.height = size.y + "px";
    }, _finish:function() {
      this._moved && (remove(this._box), removeClass(this._container, "leaflet-crosshair"));
      enableTextSelection();
      enableImageDrag();
      off(document, {contextmenu:stop, mousemove:this._onMouseMove, mouseup:this._onMouseUp, keydown:this._onKeyDown}, this);
    }, _onMouseUp:function(e) {
      if (e.which === 1 || e.button === 1) {
        this._finish(), this._moved && (this._clearDeferredResetState(), this._resetStateTimeout = setTimeout(bind(this._resetState, this), 0), e = new LatLngBounds(this._map.containerPointToLatLng(this._startPoint), this._map.containerPointToLatLng(this._point)), this._map.fitBounds(e).fire("boxzoomend", {boxZoomBounds:e}));
      }
    }, _onKeyDown:function(e) {
      e.keyCode === 27 && (this._finish(), this._clearDeferredResetState(), this._resetState());
    }});
    Map.addInitHook("addHandler", "boxZoom", BoxZoom);
    Map.mergeOptions({doubleClickZoom:!0});
    var DoubleClickZoom = Handler.extend({addHooks:function() {
      this._map.on("dblclick", this._onDoubleClick, this);
    }, removeHooks:function() {
      this._map.off("dblclick", this._onDoubleClick, this);
    }, _onDoubleClick:function(e) {
      var map = this._map, oldZoom = map.getZoom(), delta = map.options.zoomDelta;
      oldZoom = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;
      map.options.doubleClickZoom === "center" ? map.setZoom(oldZoom) : map.setZoomAround(e.containerPoint, oldZoom);
    }});
    Map.addInitHook("addHandler", "doubleClickZoom", DoubleClickZoom);
    Map.mergeOptions({dragging:!0, inertia:!0, inertiaDeceleration:3400, inertiaMaxSpeed:Infinity, easeLinearity:0.2, worldCopyJump:!1, maxBoundsViscosity:0.0});
    var Drag = Handler.extend({addHooks:function() {
      if (!this._draggable) {
        var map = this._map;
        this._draggable = new Draggable(map._mapPane, map._container);
        this._draggable.on({dragstart:this._onDragStart, drag:this._onDrag, dragend:this._onDragEnd}, this);
        this._draggable.on("predrag", this._onPreDragLimit, this);
        map.options.worldCopyJump && (this._draggable.on("predrag", this._onPreDragWrap, this), map.on("zoomend", this._onZoomEnd, this), map.whenReady(this._onZoomEnd, this));
      }
      addClass(this._map._container, "leaflet-grab leaflet-touch-drag");
      this._draggable.enable();
      this._positions = [];
      this._times = [];
    }, removeHooks:function() {
      removeClass(this._map._container, "leaflet-grab");
      removeClass(this._map._container, "leaflet-touch-drag");
      this._draggable.disable();
    }, moved:function() {
      return this._draggable && this._draggable._moved;
    }, moving:function() {
      return this._draggable && this._draggable._moving;
    }, _onDragStart:function() {
      var map = this._map;
      map._stop();
      if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
        var bounds = toLatLngBounds(this._map.options.maxBounds);
        this._offsetLimit = toBounds(this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1), this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1).add(this._map.getSize()));
        this._viscosity = Math.min(1.0, Math.max(0.0, this._map.options.maxBoundsViscosity));
      } else {
        this._offsetLimit = null;
      }
      map.fire("movestart").fire("dragstart");
      map.options.inertia && (this._positions = [], this._times = []);
    }, _onDrag:function(e) {
      if (this._map.options.inertia) {
        var time = this._lastTime = +new Date(), pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;
        this._positions.push(pos);
        this._times.push(time);
        this._prunePositions(time);
      }
      this._map.fire("move", e).fire("drag", e);
    }, _prunePositions:function(time) {
      for (; this._positions.length > 1 && time - this._times[0] > 50;) {
        this._positions.shift(), this._times.shift();
      }
    }, _onZoomEnd:function() {
      var pxCenter = this._map.getSize().divideBy(2);
      this._initialWorldOffset = this._map.latLngToLayerPoint([0, 0]).subtract(pxCenter).x;
      this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
    }, _viscousLimit:function(value, threshold) {
      return value - (value - threshold) * this._viscosity;
    }, _onPreDragLimit:function() {
      if (this._viscosity && this._offsetLimit) {
        var offset = this._draggable._newPos.subtract(this._draggable._startPos), limit = this._offsetLimit;
        offset.x < limit.min.x && (offset.x = this._viscousLimit(offset.x, limit.min.x));
        offset.y < limit.min.y && (offset.y = this._viscousLimit(offset.y, limit.min.y));
        offset.x > limit.max.x && (offset.x = this._viscousLimit(offset.x, limit.max.x));
        offset.y > limit.max.y && (offset.y = this._viscousLimit(offset.y, limit.max.y));
        this._draggable._newPos = this._draggable._startPos.add(offset);
      }
    }, _onPreDragWrap:function() {
      var worldWidth = this._worldWidth, halfWidth = Math.round(worldWidth / 2), dx = this._initialWorldOffset, x = this._draggable._newPos.x, newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx;
      worldWidth = (x + halfWidth + dx) % worldWidth - halfWidth - dx;
      dx = Math.abs(newX1 + dx) < Math.abs(worldWidth + dx) ? newX1 : worldWidth;
      this._draggable._absPos = this._draggable._newPos.clone();
      this._draggable._newPos.x = dx;
    }, _onDragEnd:function(e) {
      var map = this._map, options = map.options, noInertia = !options.inertia || e.noInertia || this._times.length < 2;
      map.fire("dragend", e);
      if (noInertia) {
        map.fire("moveend");
      } else {
        this._prunePositions(+new Date());
        e = this._lastPos.subtract(this._positions[0]);
        var ease = options.easeLinearity;
        noInertia = e.multiplyBy(ease / ((this._lastTime - this._times[0]) / 1000));
        var speed = noInertia.distanceTo([0, 0]);
        e = Math.min(options.inertiaMaxSpeed, speed);
        noInertia = noInertia.multiplyBy(e / speed);
        var decelerationDuration = e / (options.inertiaDeceleration * ease), offset = noInertia.multiplyBy(-decelerationDuration / 2).round();
        offset.x || offset.y ? (offset = map._limitOffset(offset, map.options.maxBounds), requestAnimFrame(function() {
          map.panBy(offset, {duration:decelerationDuration, easeLinearity:ease, noMoveStart:!0, animate:!0});
        })) : map.fire("moveend");
      }
    }});
    Map.addInitHook("addHandler", "dragging", Drag);
    Map.mergeOptions({keyboard:!0, keyboardPanDelta:80});
    var Keyboard = Handler.extend({keyCodes:{left:[37], right:[39], down:[40], up:[38], zoomIn:[187, 107, 61, 171], zoomOut:[189, 109, 54, 173]}, initialize:function(map) {
      this._map = map;
      this._setPanDelta(map.options.keyboardPanDelta);
      this._setZoomDelta(map.options.zoomDelta);
    }, addHooks:function() {
      var container = this._map._container;
      container.tabIndex <= 0 && (container.tabIndex = "0");
      on(container, {focus:this._onFocus, blur:this._onBlur, mousedown:this._onMouseDown}, this);
      this._map.on({focus:this._addHooks, blur:this._removeHooks}, this);
    }, removeHooks:function() {
      this._removeHooks();
      off(this._map._container, {focus:this._onFocus, blur:this._onBlur, mousedown:this._onMouseDown}, this);
      this._map.off({focus:this._addHooks, blur:this._removeHooks}, this);
    }, _onMouseDown:function() {
      if (!this._focused) {
        var body = document.body, docEl = document.documentElement, top = body.scrollTop || docEl.scrollTop;
        body = body.scrollLeft || docEl.scrollLeft;
        this._map._container.focus();
        window.scrollTo(body, top);
      }
    }, _onFocus:function() {
      this._focused = !0;
      this._map.fire("focus");
    }, _onBlur:function() {
      this._focused = !1;
      this._map.fire("blur");
    }, _setPanDelta:function(panDelta) {
      var keys = this._panKeys = {}, codes = this.keyCodes, len;
      var i = 0;
      for (len = codes.left.length; i < len; i++) {
        keys[codes.left[i]] = [-1 * panDelta, 0];
      }
      i = 0;
      for (len = codes.right.length; i < len; i++) {
        keys[codes.right[i]] = [panDelta, 0];
      }
      i = 0;
      for (len = codes.down.length; i < len; i++) {
        keys[codes.down[i]] = [0, panDelta];
      }
      i = 0;
      for (len = codes.up.length; i < len; i++) {
        keys[codes.up[i]] = [0, -1 * panDelta];
      }
    }, _setZoomDelta:function(zoomDelta) {
      var keys = this._zoomKeys = {}, codes = this.keyCodes, len;
      var i = 0;
      for (len = codes.zoomIn.length; i < len; i++) {
        keys[codes.zoomIn[i]] = zoomDelta;
      }
      i = 0;
      for (len = codes.zoomOut.length; i < len; i++) {
        keys[codes.zoomOut[i]] = -zoomDelta;
      }
    }, _addHooks:function() {
      on(document, "keydown", this._onKeyDown, this);
    }, _removeHooks:function() {
      off(document, "keydown", this._onKeyDown, this);
    }, _onKeyDown:function(e) {
      if (!(e.altKey || e.ctrlKey || e.metaKey)) {
        var key = e.keyCode, map = this._map;
        if (key in this._panKeys) {
          map._panAnim && map._panAnim._inProgress || (key = this._panKeys[key], e.shiftKey && (key = toPoint(key).multiplyBy(3)), map.options.maxBounds && (key = map._limitOffset(toPoint(key), map.options.maxBounds)), map.options.worldCopyJump ? (key = map.wrapLatLng(map.unproject(map.project(map.getCenter()).add(key))), map.panTo(key)) : map.panBy(key));
        } else if (key in this._zoomKeys) {
          map.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);
        } else if (key === 27 && map._popup && map._popup.options.closeOnEscapeKey) {
          map.closePopup();
        } else {
          return;
        }
        stop(e);
      }
    }});
    Map.addInitHook("addHandler", "keyboard", Keyboard);
    Map.mergeOptions({scrollWheelZoom:!0, wheelDebounceTime:40, wheelPxPerZoomLevel:60});
    var ScrollWheelZoom = Handler.extend({addHooks:function() {
      on(this._map._container, "wheel", this._onWheelScroll, this);
      this._delta = 0;
    }, removeHooks:function() {
      off(this._map._container, "wheel", this._onWheelScroll, this);
    }, _onWheelScroll:function(e) {
      var delta = getWheelDelta(e), debounce = this._map.options.wheelDebounceTime;
      this._delta += delta;
      this._lastMousePos = this._map.mouseEventToContainerPoint(e);
      this._startTime || (this._startTime = +new Date());
      delta = Math.max(debounce - (+new Date() - this._startTime), 0);
      clearTimeout(this._timer);
      this._timer = setTimeout(bind(this._performZoom, this), delta);
      stop(e);
    }, _performZoom:function() {
      var map = this._map, zoom = map.getZoom(), snap = this._map.options.zoomSnap || 0;
      map._stop();
      var d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(this._delta / (this._map.options.wheelPxPerZoomLevel * 4))))) / Math.LN2;
      snap = snap ? Math.ceil(d3 / snap) * snap : d3;
      snap = map._limitZoom(zoom + (this._delta > 0 ? snap : -snap)) - zoom;
      this._delta = 0;
      this._startTime = null;
      snap && (map.options.scrollWheelZoom === "center" ? map.setZoom(zoom + snap) : map.setZoomAround(this._lastMousePos, zoom + snap));
    }});
    Map.addInitHook("addHandler", "scrollWheelZoom", ScrollWheelZoom);
    Map.mergeOptions({tapHold:Browser.touchNative && Browser.safari && Browser.mobile, tapTolerance:15});
    var TapHold = Handler.extend({addHooks:function() {
      on(this._map._container, "touchstart", this._onDown, this);
    }, removeHooks:function() {
      off(this._map._container, "touchstart", this._onDown, this);
    }, _onDown:function(e) {
      clearTimeout(this._holdTimeout);
      if (e.touches.length === 1) {
        var first = e.touches[0];
        this._startPos = this._newPos = new Point(first.clientX, first.clientY);
        this._holdTimeout = setTimeout(bind(function() {
          this._cancel();
          this._isTapValid() && (on(document, "touchend", preventDefault), on(document, "touchend touchcancel", this._cancelClickPrevent), this._simulateEvent("contextmenu", first));
        }, this), 600);
        on(document, "touchend touchcancel contextmenu", this._cancel, this);
        on(document, "touchmove", this._onMove, this);
      }
    }, _cancelClickPrevent:function cancelClickPrevent() {
      off(document, "touchend", preventDefault);
      off(document, "touchend touchcancel", cancelClickPrevent);
    }, _cancel:function() {
      clearTimeout(this._holdTimeout);
      off(document, "touchend touchcancel contextmenu", this._cancel, this);
      off(document, "touchmove", this._onMove, this);
    }, _onMove:function(e) {
      e = e.touches[0];
      this._newPos = new Point(e.clientX, e.clientY);
    }, _isTapValid:function() {
      return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
    }, _simulateEvent:function(type, e) {
      type = new MouseEvent(type, {bubbles:!0, cancelable:!0, view:window, screenX:e.screenX, screenY:e.screenY, clientX:e.clientX, clientY:e.clientY});
      type._simulated = !0;
      e.target.dispatchEvent(type);
    }});
    Map.addInitHook("addHandler", "tapHold", TapHold);
    Map.mergeOptions({touchZoom:Browser.touch, bounceAtZoomLimits:!0});
    var TouchZoom = Handler.extend({addHooks:function() {
      addClass(this._map._container, "leaflet-touch-zoom");
      on(this._map._container, "touchstart", this._onTouchStart, this);
    }, removeHooks:function() {
      removeClass(this._map._container, "leaflet-touch-zoom");
      off(this._map._container, "touchstart", this._onTouchStart, this);
    }, _onTouchStart:function(e) {
      var map = this._map;
      if (e.touches && e.touches.length === 2 && !map._animatingZoom && !this._zooming) {
        var p1 = map.mouseEventToContainerPoint(e.touches[0]), p2 = map.mouseEventToContainerPoint(e.touches[1]);
        this._centerPoint = map.getSize()._divideBy(2);
        this._startLatLng = map.containerPointToLatLng(this._centerPoint);
        map.options.touchZoom !== "center" && (this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2)));
        this._startDist = p1.distanceTo(p2);
        this._startZoom = map.getZoom();
        this._moved = !1;
        this._zooming = !0;
        map._stop();
        on(document, "touchmove", this._onTouchMove, this);
        on(document, "touchend touchcancel", this._onTouchEnd, this);
        preventDefault(e);
      }
    }, _onTouchMove:function(e) {
      if (e.touches && e.touches.length === 2 && this._zooming) {
        var map = this._map, p1 = map.mouseEventToContainerPoint(e.touches[0]), p2 = map.mouseEventToContainerPoint(e.touches[1]), scale = p1.distanceTo(p2) / this._startDist;
        this._zoom = map.getScaleZoom(scale, this._startZoom);
        !map.options.bounceAtZoomLimits && (this._zoom < map.getMinZoom() && scale < 1 || this._zoom > map.getMaxZoom() && scale > 1) && (this._zoom = map._limitZoom(this._zoom));
        if (map.options.touchZoom === "center") {
          if (this._center = this._startLatLng, scale === 1) {
            return;
          }
        } else {
          p1 = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);
          if (scale === 1 && p1.x === 0 && p1.y === 0) {
            return;
          }
          this._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(p1), this._zoom);
        }
        this._moved || (map._moveStart(!0, !1), this._moved = !0);
        cancelAnimFrame(this._animRequest);
        map = bind(map._move, map, this._center, this._zoom, {pinch:!0, round:!1}, void 0);
        this._animRequest = requestAnimFrame(map, this, !0);
        preventDefault(e);
      }
    }, _onTouchEnd:function() {
      this._moved && this._zooming ? (this._zooming = !1, cancelAnimFrame(this._animRequest), off(document, "touchmove", this._onTouchMove, this), off(document, "touchend touchcancel", this._onTouchEnd, this), this._map.options.zoomAnimation ? this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), !0, this._map.options.zoomSnap) : this._map._resetView(this._center, this._map._limitZoom(this._zoom))) : this._zooming = !1;
    }});
    Map.addInitHook("addHandler", "touchZoom", TouchZoom);
    Map.BoxZoom = BoxZoom;
    Map.DoubleClickZoom = DoubleClickZoom;
    Map.Drag = Drag;
    Map.Keyboard = Keyboard;
    Map.ScrollWheelZoom = ScrollWheelZoom;
    Map.TapHold = TapHold;
    Map.TouchZoom = TouchZoom;
    exports.Bounds = Bounds;
    exports.Browser = Browser;
    exports.CRS = CRS;
    exports.Canvas = Canvas;
    exports.Circle = Circle;
    exports.CircleMarker = CircleMarker;
    exports.Class = Class;
    exports.Control = Control;
    exports.DivIcon = DivIcon;
    exports.DivOverlay = DivOverlay;
    exports.DomEvent = DomEvent;
    exports.DomUtil = DomUtil;
    exports.Draggable = Draggable;
    exports.Evented = Evented;
    exports.FeatureGroup = FeatureGroup;
    exports.GeoJSON = GeoJSON;
    exports.GridLayer = GridLayer;
    exports.Handler = Handler;
    exports.Icon = Icon;
    exports.ImageOverlay = ImageOverlay;
    exports.LatLng = LatLng;
    exports.LatLngBounds = LatLngBounds;
    exports.Layer = Layer;
    exports.LayerGroup = LayerGroup;
    exports.LineUtil = LineUtil;
    exports.Map = Map;
    exports.Marker = Marker;
    exports.Mixin = Mixin;
    exports.Path = Path;
    exports.Point = Point;
    exports.PolyUtil = PolyUtil;
    exports.Polygon = Polygon;
    exports.Polyline = Polyline;
    exports.Popup = Popup;
    exports.PosAnimation = PosAnimation;
    exports.Projection = index;
    exports.Rectangle = Rectangle;
    exports.Renderer = Renderer;
    exports.SVG = SVG;
    exports.SVGOverlay = SVGOverlay;
    exports.TileLayer = TileLayer;
    exports.Tooltip = Tooltip;
    exports.Transformation = Transformation;
    exports.Util = Util;
    exports.VideoOverlay = VideoOverlay;
    exports.bind = bind;
    exports.bounds = toBounds;
    exports.canvas = canvas;
    exports.circle = function(latlng, options, legacyOptions) {
      return new Circle(latlng, options, legacyOptions);
    };
    exports.circleMarker = function(latlng, options) {
      return new CircleMarker(latlng, options);
    };
    exports.control = control;
    exports.divIcon = function(options) {
      return new DivIcon(options);
    };
    exports.extend = extend;
    exports.featureGroup = function(layers, options) {
      return new FeatureGroup(layers, options);
    };
    exports.geoJSON = geoJSON;
    exports.geoJson = geoJSON;
    exports.gridLayer = function(options) {
      return new GridLayer(options);
    };
    exports.icon = function(options) {
      return new Icon(options);
    };
    exports.imageOverlay = function(url, bounds, options) {
      return new ImageOverlay(url, bounds, options);
    };
    exports.latLng = toLatLng;
    exports.latLngBounds = toLatLngBounds;
    exports.layerGroup = function(layers, options) {
      return new LayerGroup(layers, options);
    };
    exports.map = function(id, options) {
      return new Map(id, options);
    };
    exports.marker = function(latlng, options) {
      return new Marker(latlng, options);
    };
    exports.point = toPoint;
    exports.polygon = function(latlngs, options) {
      return new Polygon(latlngs, options);
    };
    exports.polyline = function(latlngs, options) {
      return new Polyline(latlngs, options);
    };
    exports.popup = function(options, source) {
      return new Popup(options, source);
    };
    exports.rectangle = function(latLngBounds, options) {
      return new Rectangle(latLngBounds, options);
    };
    exports.setOptions = setOptions;
    exports.stamp = stamp;
    exports.svg = svg;
    exports.svgOverlay = function(el, bounds, options) {
      return new SVGOverlay(el, bounds, options);
    };
    exports.tileLayer = tileLayer;
    exports.tooltip = function(options, source) {
      return new Tooltip(options, source);
    };
    exports.transformation = toTransformation;
    exports.version = "1.9.4";
    exports.videoOverlay = function(video, bounds, options) {
      return new VideoOverlay(video, bounds, options);
    };
    var oldL = window.L;
    exports.noConflict = function() {
      window.L = oldL;
      return this;
    };
    window.L = exports;
  });
};

//# sourceMappingURL=module$node_modules$leaflet$dist$leaflet_src.js.map
